Todo List de DÃ©veloppement â€“ Projet EkriMenDarek

âš™ï¸ Phases de DÃ©veloppement Backend (NestJS, Prisma, PostgreSQL)

Phase B1 â€“ Initialisation du Projet Backend

\[ \] Initialiser le projet NestJS : CrÃ©ation dâ€™une application NestJS en TypeScript via la CLI (structure modulaire par dÃ©faut) avec configuration de base (fichier .env pour variables sensibles, Git initialisÃ©).

\[ \] Configurer les outils de base : Mettre en place le linter ESLint, le formateur de code Prettier et les scripts NPM pour assurer une qualitÃ© de code homogÃ¨ne.

\[ \] Installer les dÃ©pendances principales : Ajout des modules NestJS nÃ©cessaires (ex: @nestjs/config pour la config, @nestjs/passport et passport-jwt pour lâ€™authentification JWT). PrÃ©parer Prisma (client Node) pour lâ€™ORM et charger le pilote PostgreSQL.

\[ \] Mettre en place la structure du projet : CrÃ©er lâ€™architecture des dossiers (src/modules, src/controllers, src/services, etc.) conformÃ©ment aux best practices NestJS, afin de faciliter lâ€™ajout de modules (auth, vÃ©hicules, agences...).

Phase B2 â€“ Base de DonnÃ©es & Prisma

\[ \] Concevoir le schÃ©ma de base de donnÃ©es : DÃ©finir avec Prisma le schÃ©ma PostgreSQL incluant les tables Utilisateur, Agence, VÃ©hicule, RÃ©servation, Paiement, Avis (review), DocumentKYC etc., avec les relations appropriÃ©es (ex: un vÃ©hicule appartient Ã  une agence, une rÃ©servation lie un utilisateur et un vÃ©hicule, etc.).

\[ \] DÃ©finir les relations et contraintes : ImplÃ©menter les relations (1-n, n-n) dans le schÃ©ma Prisma â€“ par ex. liaison entre Utilisateur et Agence (un utilisateur peut Ãªtre liÃ© Ã  une agence en tant que propriÃ©taire), contraintes dâ€™unicitÃ© (email utilisateur unique), clÃ©s Ã©trangÃ¨res pour lâ€™intÃ©gritÃ© rÃ©fÃ©rentielle.

\[ \] GÃ©nÃ©rer la migration et la base : ExÃ©cuter prisma migrate pour crÃ©er le schÃ©ma dans PostgreSQL. VÃ©rifier que la base est opÃ©rationnelle (ex: via Prisma Studio ou un client SQL) et que toutes les tables/modules requis sont prÃ©sents.

\[ \] Configurer Prisma Client : GÃ©nÃ©rer le client Prisma (prisma generate) et lâ€™intÃ©grer dans NestJS (module Prisma) pour permettre aux services dâ€™accÃ©der facilement aux donnÃ©es. PrÃ©voir Ã©ventuellement des donnÃ©es de dÃ©part (seed) â€“ ex: crÃ©ation dâ€™un compte administrateur par dÃ©faut ou de quelques agences/test pour les dev.

Phase B3 â€“ Logique MÃ©tier & Modules NestJS

\[ \] ImplÃ©menter le module Authentification : CrÃ©er le module dâ€™authentification (controllers, service) avec inscription (distinguant compte client vs compte agence via un champ rÃ´le), login (vÃ©rification du mot de passe hachÃ© via bcrypt), Ã©mission de JWT (JSON Web Token) en cas de succÃ¨s, et Ã©ventuellement refresh token pour prolonger les sessions. Inclure la validation de base (mot de passe fort, email valide) et une option de rÃ©initialisation de mot de passe par email.

\[ \] ImplÃ©menter le module Utilisateurs/Profils : GÃ©rer le profil des utilisateurs (clients et propriÃ©taires dâ€™agence). Permettre la mise Ã  jour du profil (coordonnÃ©es, photo de profil), consulter son statut KYC (voir module KYC), et pour un utilisateur de type agence, accÃ©der aux donnÃ©es de son agence.

\[ \] ImplÃ©menter le module Agences : Permettre la crÃ©ation et la gestion des agences de location. Chaque agence est liÃ©e Ã  un utilisateur propriÃ©taire. Inclure des endpoints pour crÃ©er/mettre Ã  jour le profil dâ€™une agence (nom, adresse, wilaya, informations de contact, documents Ã©ventuels), et un endpoint public pour lister les agences (pour usage Ã©ventuel dans la recherche de vÃ©hicules par localisation). Ce module servira de base au back-office agence (pas dâ€™interface ici mais des APIs).

\[ \] ImplÃ©menter le module VÃ©hicules : CrÃ©er le CRUD des voitures de location. Permettre aux comptes agence dâ€™ajouter un vÃ©hicule (marque, modÃ¨le, annÃ©e, type de boÃ®te de vitesses, carburant, tarif/jour, montant de caution requis, photos, etc.), de modifier ou dÃ©sactiver un vÃ©hicule (ex: le passer â€œhors ligneâ€ lorsquâ€™il nâ€™est pas disponible ou en maintenance). PrÃ©voir un champ de disponibilitÃ© (disponible/indisponible) pour quâ€™une agence gÃ¨re sa flotte en un clic, et stocker les informations nÃ©cessaires aux filtres de recherche (ex: type de carburant, transmission, localisation de lâ€™agence propriÃ©taire).

\[ \] ImplÃ©menter le module RÃ©servations : GÃ©rer tout le cycle de vie dâ€™une rÃ©servation de vÃ©hicule. CrÃ©er un endpoint pour effectuer une demande de rÃ©servation (client authentifiÃ© choisissant un vÃ©hicule, des dates de dÃ©but/fin, etc.), qui crÃ©e une rÃ©servation en statut "en attente". IntÃ©grer la logique de confirmation agence : donner la possibilitÃ© Ã  lâ€™agence de valider ou refuser la rÃ©servation dans un dÃ©lai imparti (ex: 2 heures) via un endpoint sÃ©curisÃ©. Si lâ€™agence confirme (ou si auto-confirmation configurÃ©e), passer la rÃ©servation au statut "confirmÃ©e". GÃ©rer aussi lâ€™annulation (par le client avant confirmation, ou par lâ€™agence, avec Ã©ventuelles pÃ©nalitÃ©s Ã  implÃ©menter plus tard). Chaque rÃ©servation doit conserver les dÃ©tails (dates, prix total, montant dâ€™acompte payÃ©, etc.) et Ãªtre liÃ©e au paiement correspondant le cas Ã©chÃ©ant.

\[ \] ImplÃ©menter le module Paiements : IntÃ©grer une solution de paiement en ligne pour les acomptes. Utiliser lâ€™API de paiement locale (ex: Satim/CIB pour cartes Edahabia ou CIB) ou une passerelle de paiement intÃ©grable. CrÃ©er un service permettant au client de payer un acompte (par ex. 10-15% du montant de la location) lors de la rÃ©servation en ligne. Assurer la sÃ©curitÃ© des transactions (redirection vers la plateforme bancaire ou usage de tokens, et HTTPS obligatoire). Enregistrer en base les transactions (montant de lâ€™acompte, rÃ©fÃ©rence de transaction) et le statut (rÃ©ussi/Ã©chouÃ©) liÃ© Ã  la rÃ©servation. PrÃ©voir un mÃ©canisme de mise Ã  jour du statut de rÃ©servation aprÃ¨s paiement rÃ©ussi (ex: passer en â€œen attente confirmation agenceâ€).

\[ \] ImplÃ©menter le module Avis/Notations : Mettre en place un systÃ¨me dâ€™Ã©valuation post-location. Permettre aux clients de laisser un avis et une note sur le vÃ©hicule/agence aprÃ¨s la restitution du vÃ©hicule, et Ã©ventuellement aux agences de noter le client (systÃ¨me de notation mutuelle pour instaurer la confiance, similaire Ã  Airbnb). CrÃ©er les entitÃ©s correspondantes (avis avec note 1-5, commentaire, liÃ© Ã  une rÃ©servation terminÃ©e). ImplÃ©menter des endpoints pour soumettre un avis et pour lister les avis dâ€™un vÃ©hicule ou dâ€™une agence (pour affichage dans le front). Assurer quâ€™un utilisateur ne peut Ã©valuer que les locations quâ€™il a effectuÃ©es.

\[ \] ImplÃ©menter le module KYC (VÃ©rification dâ€™IdentitÃ©) : Ajouter une fonctionnalitÃ© de KYC lÃ©ger pour les clients. Endpoint pour upload de documents (ex: permis de conduire scannÃ©/photo et selfie de lâ€™utilisateur) afin de vÃ©rifier son identitÃ© et son Ã©ligibilitÃ© (Ã¢ge et anciennetÃ© du permis). Stocker ces documents de faÃ§on sÃ©curisÃ©e (par ex. sur un stockage S3 ou en base codÃ©e). IntÃ©grer un systÃ¨me OCR (reconnaissance optique de caractÃ¨res) pour lire automatiquement les informations du permis (nom, date de dÃ©livrance...) et vÃ©rifier que le permis est valide et assez ancien (ex: \>2 ans). Marquer dans le profil utilisateur le statut VÃ©rifiÃ© une fois les documents validÃ©s (Ã©ventuellement validation automatique via OCR \+ vÃ©rification manuelle si nÃ©cessaire). Ce module contribue Ã  la confiance sur la plateforme.

\[ \] ImplÃ©menter le module Notifications : Mettre en place lâ€™envoi de notifications transactionnelles. Par exemple, Ã  la confirmation de rÃ©servation, envoi dâ€™un email rÃ©capitulatif au client (voucher) ainsi quâ€™Ã  lâ€™agence. PrÃ©voir lâ€™envoi dâ€™un message WhatsApp via une API tierce (WhatsApp Business API ou Twilio) contenant les dÃ©tails essentiels, Ã©tant donnÃ© lâ€™usage local de WhatsApp pour informer rapidement le client. Configurer NestJS Mailer ou un service externe (SendGrid, Mailjetâ€¦) pour les emails. Assurer que ces envois se dÃ©clenchent aux bons Ã©vÃ©nements (confirmation, annulation, etc.).

Phase B4 â€“ SÃ©curitÃ© & ContrÃ´les

\[ \] GÃ©rer les autorisations (RBAC) : DÃ©finir les rÃ´les utilisateur (client, agence, admin) et implÃ©menter des guards NestJS pour sÃ©curiser les routes en fonction du rÃ´le. Par ex., les endpoints de gestion de vÃ©hicules ou de confirmation de rÃ©servation doivent Ãªtre accessibles uniquement aux utilisateurs rÃ´le agence propriÃ©taires de ces donnÃ©es; les endpoints dâ€™administration (sâ€™il y en a pour la modÃ©ration, etc.) seulement aux admins.

\[ \] ProtÃ©ger les routes et donnÃ©es sensibles : Configurer la stratÃ©gie JWT (via Passport) pour exiger un token valide sur les routes authentifiÃ©es. Imposer la hachage des mots de passe (ex: bcrypt avec salage) Ã  lâ€™enregistrement. Ne jamais stocker de donnÃ©es bancaires en clair cÃ´tÃ© backend (utiliser les tokens de lâ€™opÃ©rateur de paiement).

\[ \] Valider les entrÃ©es : Utiliser les DTOs et decorators (class-validator) de NestJS pour valider systÃ©matiquement les donnÃ©es en entrÃ©e des endpoints (formats dâ€™email, champs requis, longueur des mots de passe, etc.) afin de prÃ©venir les erreurs et injections.

\[ \] Configurer la sÃ©curitÃ© HTTP globale : Activer CORS correctement pour autoriser le domaine du frontend Ã  consommer lâ€™API. Utiliser Helmet middleware pour ajouter des en-tÃªtes de sÃ©curitÃ© HTTP standard. Mettre en place un rate limiting (par ex. @nestjs/throttler) pour limiter les appels abusifs sur les endpoints publics (prÃ©venir brute force sur /login, etc.).

\[ \] Logs et surveillance : Configurer un systÃ¨me de log (NestJS logger par dÃ©faut ou Winston) pour tracer les requÃªtes importantes (succÃ¨s et erreurs). PrÃ©voir de monitorer les exceptions et dâ€™Ã©ventuellement connecter un service de suivi des erreurs (ex: Sentry) une fois en production, afin de pouvoir rÃ©agir rapidement aux bugs ou failles de sÃ©curitÃ©.

Phase B5 â€“ Documentation & QualitÃ©

\[ \] Documentation de lâ€™API (Swagger) : IntÃ©grer Swagger (OpenAPI) dans NestJS en gÃ©nÃ©rant automatiquement la documentation des endpoints. Fournir un accÃ¨s (ex: /api-docs) listant toutes les routes, mÃ©thodes, schÃ©mas de requÃªte/rÃ©ponse et codes de statut, pour que les dÃ©veloppeurs frontend et partenaires puissent facilement comprendre comment consommer lâ€™API.

\[ \] Documentation dÃ©veloppeur (README) : RÃ©diger un fichier README ou une documentation technique expliquant lâ€™installation du backend, la configuration nÃ©cessaire (.env Ã  remplir â€“ par ex. URL BDD, clÃ©s JWT, clÃ© API paiement, etc.), ainsi que les commandes utiles (scripts pour lancer en dev, exÃ©cuter les tests, migrations Prisma...). Inclure une section sur lâ€™architecture des modules et Ã©ventuellement un schÃ©ma simplifiÃ© de lâ€™architecture pour situer chaque partie.

\[ \] Documentation utilisateur/admin (Ã  prÃ©voir) : PrÃ©parer Ã  moyen terme une documentation ou aide Ã  destination des utilisateurs finaux du systÃ¨me back-office (agences) et des administrateurs de la plateforme. Par exemple un mini-guide dâ€™utilisation de lâ€™interface agence (gestion du parc automobile, traitement des rÃ©servations) afin de faciliter lâ€™adoption lors du lancement. (Cette tÃ¢che peut Ãªtre planifiÃ©e vers la fin du dÃ©veloppement, une fois lâ€™UI admin/agence prÃªte).

Phase B6 â€“ Tests, CI/CD et DÃ©ploiement

\[ \] Ã‰crire des tests unitaires : Pour chaque service critique (authentification, rÃ©servation, paiement...), dÃ©velopper des tests unitaires avec Jest afin de vÃ©rifier le comportement mÃ©tier (ex: crÃ©ation de rÃ©servation ne dÃ©passant pas le stock, calcul correct de lâ€™acompte, etc.). Ceci garantit la non-rÃ©gression lors des modifications futures.

\[ \] Mettre en place des tests dâ€™intÃ©gration : Tester les endpoints principaux via un outil comme Supertest ou enchainement de requÃªtes, pour sâ€™assurer quâ€™un flux complet (ex: inscription \-\> ajout vÃ©hicule \-\> rÃ©servation \-\> paiement) fonctionne comme prÃ©vu. Utiliser une base de test (ou transactions annulÃ©es) pour isoler ces tests.

\[ \] IntÃ©gration Continue (CI) : Configurer un pipeline (par ex. GitHub Actions ou GitLab CI) qui, Ã  chaque commit/pull request, lance automatiquement le linter et la suite de tests. Ce pipeline doit alerter en cas dâ€™Ã©chec afin dâ€™assurer que seule du code vÃ©rifiÃ© est fusionnÃ©.

\[ \] Conteneurisation Docker : Ã‰crire un Dockerfile pour le backend (Node 18+, Nest build, production ready) et un fichier docker-compose.yml pour orchestrer lâ€™application et ses services (ex: base de donnÃ©es Postgres, peut-Ãªtre un service de stockage minio pour les fichiers si nÃ©cessaire). Cela permettra de dÃ©ployer plus facilement sur un serveur ou cloud. Tester lâ€™exÃ©cution du backend en container localement.

\[ \] DÃ©ploiement Continu : PrÃ©parer le dÃ©ploiement sur un environnement cloud. Par exemple, configurer un pipeline CD qui, aprÃ¨s validation en CI, dÃ©ploie lâ€™image Docker sur un serveur (VPS, AWS EC2/ECS, etc.) ou une plateforme PaaS. Sâ€™assurer de la gestion des configurations pour chaque environnement (variables .env de prod, clÃ©s API rÃ©elles, etc.). PrÃ©voir un environnement de staging pour tester en conditions proches de la prod avant la mise en ligne officielle.

\[ \] Monitoring & Logs en production : Une fois dÃ©ployÃ©, mettre en place la surveillance de lâ€™application (santÃ© du serveur, uptime) et la centralisation des logs (via un service cloud ou un serveur de logs) pour pouvoir dÃ©tecter rapidement les erreurs runtime ou des usages anormaux.

ğŸ¨ Phases de DÃ©veloppement Frontend (Next.js, TypeScript, TailwindCSS)

Phase F1 â€“ Setup Initial du Frontend

\[ \] Initialiser le projet Next.js : CrÃ©er lâ€™application front avec Next.js 13+ en TypeScript (ex: via create-next-app). Configurer la structure de base (dossiers pages ou app selon lâ€™architecture choisie, dossier components, etc.) et vÃ©rifier le bon fonctionnement en mode dÃ©veloppement.

\[ \] IntÃ©grer Tailwind CSS : Installer TailwindCSS et le configurer (fichier tailwind.config.js avec les couleurs de base, points de rupture responsives). Inclure Tailwind dans les styles globaux, activer le purge des classes inutilisÃ©es en production pour optimiser le poids CSS.

\[ \] Configurer les outils de qualitÃ© : Sâ€™assurer que ESLint et Prettier sont configurÃ©s cÃ´tÃ© frontend (peut Ãªtre fait via template Next.js). DÃ©finir les rÃ¨gles spÃ©cifiques (par ex. rÃ¨gle pour lâ€™ordre des imports, usage de hooks, etc.) pour maintenir un code propre.

\[ \] Mise en place du routing : Si Next.js en mode Pages, crÃ©er les premiÃ¨res pages vides pour les principales routes (par ex. pages/index.tsx, pages/recherche.tsx, pages/vehicule/\[id\].tsx, pages/dashboard-agence.tsx, etc.). Si Next.js App Router, crÃ©er les segments Ã©quivalents. Configurer un systÃ¨me de routes protÃ©gÃ©es pour les pages nÃ©cessitant login (ex: tableau de bord agence) â€“ ceci pourra Ãªtre fait via une redirection dans le getServerSideProps ou via un hook dâ€™effet vÃ©rifiant le token JWT.

\[ \] Environnement dâ€™intÃ©gration API : CrÃ©er un fichier de configuration pour les appels API (par ex. dÃ©finir NEXT\_PUBLIC\_API\_URL dans le .env.local du frontend pointant vers lâ€™URL du backend). Installer une librairie HTTP si souhaitÃ© (ex: Axios) ou prÃ©parer un petit wrapper autour de fetch pour centraliser les appels (incluant automatiquement le header dâ€™auth JWT). VÃ©rifier en appelant une route simple du backend (ex: ping) que la communication front-back est bien Ã©tablie en dev (CORS ok).

Phase F2 â€“ SystÃ¨me de Design (UI Kit)

\[ \] DÃ©finir la charte graphique : Ã‰tablir le design system de lâ€™application web â€“ palette de couleurs (en lien avec lâ€™identitÃ© visuelle, par ex. bleu/turquoise pour confiance dâ€™aprÃ¨s le pitch), polices de caractÃ¨res (ex: sans-serif moderne), tailles de police, et guidelines de mise en page (espacements, arrondis des boutons, etc.). Documenter ces choix pour que toute lâ€™Ã©quipe les suive.

\[ \] Configurer Tailwind pour le thÃ¨me : Personnaliser le thÃ¨me Tailwind en ajoutant les couleurs de la charte, Ã©ventuellement les fonts via plugin, et les breakpoints si besoin. DÃ©finir des classes utilitaires globales si certaines doivent Ãªtre rÃ©currentes (ex: classes pour les boÃ®tes de dialogue, ombres, etc.).

\[ \] PrÃ©parer les composants de base : Concevoir les composants atomiques de lâ€™UI en accord avec le design system. Par exemple : styles de boutons (primaire, secondaire, disabled), champs de formulaire (input texte, select, checkbox, etc.), en-tÃªtes et paragraphes (typographie), cartes et conteneurs de sections. Ces composants de base serviront de fondation pour construire des composants plus complexes.

\[ \] Mise en place Ã©ventuellement dâ€™un Storybook (optionnel) : Pour faciliter la conception UI, envisager dâ€™instancier Storybook et y documenter chaque composant du design system. Ceci permet de valider lâ€™apparence et le comportement des composants isolÃ©ment et servira de rÃ©fÃ©rence de style pour les dÃ©veloppeurs.

Phase F3 â€“ DÃ©veloppement des Composants UI

\[ \] CrÃ©er le composant dâ€™en-tÃªte (Header/NavBar) : Barre de navigation supÃ©rieure avec le logo, le champ de recherche rapide (sÃ©lection de wilaya/commune, dates) accessible sur la page dâ€™accueil, et les liens de navigation (par ex. explorer, contact, etc.). Inclure Ã©galement les boutons/menus de connexion et dâ€™accÃ¨s au profil (ou au tableau de bord agence si lâ€™utilisateur est connectÃ© en tant quâ€™agence). Doit Ãªtre responsive (menu burger sur mobile).

\[ \] CrÃ©er le composant de pied de page (Footer) : Inclure les informations de base (copyright, lien CGU/CGV, politique de confidentialitÃ©), ainsi que des liens utiles (aide, contact) et Ã©ventuellement les rÃ©seaux sociaux. Le footer doit rester simple et cohÃ©rent avec le design (couleurs plus sobres).

\[ \] CrÃ©er le composant de carte vÃ©hicule (liste) : ReprÃ©sentation compacte dâ€™un vÃ©hicule dans une liste de rÃ©sultats. Ce composant affichera la photo du vÃ©hicule, son nom/modÃ¨le, le prix par jour, la note moyenne (Ã©toiles) et Ã©ventuellement un tag pour lâ€™agence ou la ville. PrÃ©voir dâ€™afficher si automatique/manuelle, essence/diesel via des icÃ´nes ou libellÃ©s. Ce composant sera utilisÃ© pour chaque item de la page de rÃ©sultats de recherche.

\[ \] CrÃ©er le composant dÃ©tail vÃ©hicule (fiche) : Sur la page de dÃ©tail dâ€™un vÃ©hicule, composant affichant les photos du vÃ©hicule (carousel), les caractÃ©ristiques dÃ©taillÃ©es (annÃ©e, kilomÃ©trage, options, conditions de location de lâ€™agence â€“ ex: caution requise, restrictions de conducteur), le tout de maniÃ¨re attractive. Inclure un bouton ou formulaire intÃ©grÃ© pour rÃ©server depuis cette fiche (sÃ©lection des dates si pas dÃ©jÃ  faites, et bouton de confirmation menant au paiement).

\[ \] CrÃ©er le composant formulaire de rÃ©servation : Modulable pour Ãªtre utilisÃ© sur la fiche vÃ©hicule ou en page sÃ©parÃ©e. Champs principaux : dates de dÃ©but/fin avec sÃ©lecteur de date (calendrier), heure Ã©ventuellement, options (si des services additionnels comme assurance rachat de franchise sont proposÃ©s), champ pour code promo Ã©ventuel. Inclure la synthÃ¨se du prix calculÃ© (X jours \* tarif \+ options) et le montant de lâ€™acompte Ã  payer maintenant. Un bouton final â€œConfirmer la rÃ©servationâ€ soumettra le tout. Ce composant devra gÃ©rer la validation de chaque champ (dates obligatoires, etc.) avant soumission.

\[ \] CrÃ©er les composants de formulaires Auth : Composant(s) pour Inscription et Connexion, possiblement sous forme de modale ou de pages dÃ©diÃ©es. Pour lâ€™inscription, inclure les champs requis (email, mot de passe, confirmation, type de compte client ou agence avec Ã©ventuellement un formulaire Ã©tendu si agence â€“ ex: nom de lâ€™agence, wilayaâ€¦). Pour la connexion, email \+ mot de passe. GÃ©rer les erreurs (identifiants incorrects) avec des messages clairs.

\[ \] CrÃ©er le composant tableau de bord agence : Ensemble de sous-composants pour lâ€™interface agence une fois connectÃ©e. Par ex.: un composant Liste des vÃ©hicules (table ou cards listant les voitures de lâ€™agence avec statut disponible/indisponible \+ bouton dâ€™Ã©dition), un composant Liste des rÃ©servations reÃ§ues (avec indication de chaque rÃ©servation en attente ou confirmÃ©e, boutons pour accepter/refuser, tri par date), et un composant Statistiques sommaires (Ã©ventuellement nombre de rÃ©servations ce mois, revenus gÃ©nÃ©rÃ©s sur acomptes, etc.). Ces composants constituent la vue Dashboard cÃ´tÃ© agence.

\[ \] CrÃ©er des composants utilitaires rÃ©utilisables : Par exemple un composant Modal gÃ©nÃ©rique (pour affichage de dialogues de confirmation, etc.), un composant Spinner/Loading pour indiquer les chargements, un composant Notification/Alert pour afficher les messages dâ€™erreur ou succÃ¨s globalement. Ces petits composants seront utilisÃ©s Ã  travers lâ€™application pour amÃ©liorer lâ€™UX.

Phase F4 â€“ Construction des Pages

\[ \] Page Accueil (Home) : Mettre en page lâ€™Ã©cran dâ€™accueil comprenant le formulaire de recherche principal (lieu de location, dates, bouton Rechercher) mis en avant. Ajouter une section de texte marketing sur le concept (â€œBooking.com de la location en AlgÃ©rieâ€) et Ã©ventuellement des call-to-action pour les agences (du type â€œRÃ©fÃ©rencez vos vÃ©hiculesâ€). Sâ€™assurer que cette page donne confiance et incite Ã  lâ€™action.

\[ \] Page RÃ©sultats de Recherche : Afficher la liste des vÃ©hicules disponibles pour les critÃ¨res choisis. Utiliser le composant carte vÃ©hicule pour chaque rÃ©sultat. Inclure des filtres latÃ©raux ou en en-tÃªte permettant dâ€™affiner la recherche : plage de prix, type de vÃ©hicule, boÃ®te auto/manuelle, carburant, montant de caution maximum, etc.. Permettre de trier les rÃ©sultats (par prix, par note). GÃ©rer la pagination ou chargement infini si le nombre de rÃ©sultats est important.

\[ \] Page DÃ©tail VÃ©hicule : Afficher le composant fiche vÃ©hicule complet pour lâ€™Ã©lÃ©ment sÃ©lectionnÃ©. Cette page doit reprendre toutes les informations utiles avant de rÃ©server : galerie de photos, description, caractÃ©ristiques, avis utilisateurs (sâ€™il y en a, sinon message â€œSoyez le premier Ã  rÃ©server ce vÃ©hicule \!â€). IntÃ©grer sur cette page le formulaire de rÃ©servation (ou un bouton qui scroll vers ce formulaire).

\[ \] Page Confirmation RÃ©servation : AprÃ¨s le processus de paiement, afficher une page de confirmation rÃ©capitulant la rÃ©servation : numÃ©ro de rÃ©servation, dÃ©tails du vÃ©hicule rÃ©servÃ©, dates, montant payÃ© en ligne et solde Ã  payer Ã  lâ€™agence, instructions pour la prise en charge (adresse de lâ€™agence, documents Ã  prÃ©senter). Remercier lâ€™utilisateur et indiquer quâ€™un email/WhatsApp de confirmation lui a Ã©tÃ© envoyÃ©.

\[ \] Espace Compte Utilisateur (Client) : CrÃ©er une section Mon Compte pour les clients. Pages pour : profil (voir/modifier ses infos personnelles, photo, mot de passe), mes documents KYC (upload permis de conduire, voir statut vÃ©rification), mes rÃ©servations (historique des rÃ©servations passÃ©es et Ã  venir, avec statuts et lien pour laisser un avis une fois terminÃ©es). Veiller Ã  protÃ©ger ces pages par auth (rediriger si non connectÃ©).

\[ \] Espace Compte Agence : Pour les utilisateurs de type agence, concevoir les pages du tableau de bord en utilisant les composants dÃ©veloppÃ©s (liste vÃ©hicules, liste rÃ©servations, etc.). Permettre Ã  lâ€™agence dâ€™ajouter un vÃ©hicule via une page/formulaire dÃ©diÃ©, ou dâ€™Ã©diter un vÃ©hicule existant. Inclure la page profil de lâ€™agence (modifier les infos de lâ€™agence, horaires dâ€™ouverture Ã©ventuellement, description) et la page mes rÃ©servations clients (rÃ©servations reÃ§ues avec dÃ©tails du client et possibilitÃ© de contacter si nÃ©cessaire). Ces pages doivent permettre Ã  lâ€™agence de gÃ©rer facilement son activitÃ©.

\[ \] Pages dâ€™Authentification : IntÃ©grer les formulaires dâ€™inscription/connexion dans des pages si ce nâ€™est pas uniquement en modal. Par exemple, une page /login et /register avec un design propre. AprÃ¨s connexion ou inscription rÃ©ussie, prÃ©voir une redirection automatique vers la page pertinente (ex: vers le tableau de bord pour une agence, ou vers la page prÃ©cÃ©dente pour un client). Si lâ€™adresse email doit Ãªtre vÃ©rifiÃ©e (feature de sÃ©curitÃ© optionnelle), implÃ©menter une page ou Ã©tat â€œVÃ©rification dâ€™email envoyÃ©eâ€.

\[ \] Page dâ€™Administration (optionnel ultÃ©rieurement) : Si un rÃ´le administrateur est prÃ©vu, concevoir une page admin minimaliste (non forcÃ©ment pour MVP) permettant de lister les agences inscrites, les vÃ©hicules, et modÃ©rer le contenu (par ex: dÃ©sactiver une agence douteuse, supprimer un avis inappropriÃ©). Cette page ne sera accessible quâ€™aux admins et pourra Ãªtre dÃ©veloppÃ©e dans une phase ultÃ©rieure une fois la base utilisateur significative.

Phase F5 â€“ Hooks & Gestion dâ€™Ã‰tat

\[ \] DÃ©velopper le hook useAuth : GÃ©rer lâ€™Ã©tat dâ€™authentification global de lâ€™utilisateur. Ce hook (ou contexte React) stocke le token JWT (p. ex. dans un cookie HTTPOnly pour sÃ©curitÃ© ou localStorage si plus simple) et les infos du profil courant. Fournir des mÃ©thodes login(), logout() et register() qui appellent lâ€™API correspondante et mettent Ã  jour lâ€™Ã©tat. GÃ©rer aussi la redirection des utilisateurs non connectÃ©s si nÃ©cessaire (ex: vers /login).

\[ \] DÃ©velopper un utilitaire API / hook useAPI : Centraliser les appels Ã  lâ€™API backend. Par exemple, crÃ©er une fonction ou un hook qui configure axios ou fetch avec lâ€™URL de base, ajoute le header Authorization avec le token JWT, et gÃ¨re globalement les erreurs (ex: si 401 non autorisÃ©, trigger un logout). Cela Ã©vite de rÃ©pÃ©ter le code dâ€™appel API dans chaque composant.

\[ \] DÃ©velopper le hook useForm (formulaires) : Pour simplifier la gestion des formulaires complexes, intÃ©grer React Hook Form ou Formik. CrÃ©er Ã©ventuellement un hook custom ou des composants wrapper pour les formulaires dâ€™inscription, de rÃ©servation, etc., afin de centraliser la logique de validation, lâ€™affichage des erreurs sous les champs, et la soumission. Ce hook facilitera la rÃ©utilisation de la logique de formulaire entre diffÃ©rentes pages.

\[ \] DÃ©velopper le hook useDisponibilite : Un hook spÃ©cifique qui, donnÃ© un vÃ©hicule et une plage de dates, interroge lâ€™API (ou les donnÃ©es chargÃ©es) pour vÃ©rifier si le vÃ©hicule est dispo. Ce hook peut Ãªtre utilisÃ© sur la page de dÃ©tail vÃ©hicule pour afficher â€œDisponibleâ€ ou â€œIndisponibleâ€ sur les dates sÃ©lectionnÃ©es, et Ã©ventuellement dÃ©sactiver le bouton de rÃ©servation si dÃ©jÃ  pris. Il peut aussi servir au formulaire de rÃ©servation pour valider quâ€™entre le moment de lâ€™affichage et la soumission rien nâ€™a changÃ©.

\[ \] DÃ©velopper le hook useNotifications : Centraliser lâ€™affichage des messages dâ€™Ã©tat dans lâ€™application. Par exemple, aprÃ¨s une action rÃ©ussie (rÃ©servation effectuÃ©e) ou Ã©chouÃ©e (erreur serveur), ce hook permet de dÃ©clencher un message global (utilisant le composant Notification/Alert). Peut Ãªtre couplÃ© Ã  un contexte ou Ã  des toast notifications pour une expÃ©rience utilisateur cohÃ©rente.

Phase F6 â€“ Onboarding & UX initiale

\[ \] Parcours dâ€™onboarding client : Concevoir lâ€™expÃ©rience de premiÃ¨re utilisation pour un client. Par exemple, si lâ€™utilisateur vient de sâ€™inscrire, afficher une petite visite guidÃ©e : survol des Ã©lÃ©ments clÃ©s (â€œIci trouvez votre voitureâ€, â€œVoyez vos rÃ©servations ici...â€ avec des info-bulles ou une pop-up tutoriel). Alternativement, afficher un bandeau explicatif sur la page dâ€™accueil pour les nouveaux, mettant en avant la simplicitÃ© du processus (recherche â†’ paiement â†’ confirmation).

\[ \] Parcours dâ€™onboarding agence : Lorsquâ€™une agence crÃ©e son compte, la guider pour complÃ©ter les Ã©tapes initiales. Par exemple, une fois connectÃ©e la premiÃ¨re fois, afficher un Ã©cran â€œBienvenueâ€ listant les prochaines Ã©tapes : 1\) ComplÃ©ter les infos de votre agence, 2\) Ajouter votre premier vÃ©hicule, 3\) Publier votre annonce. Offrir des liens/boutons directs pour rÃ©aliser chacune de ces Ã©tapes. Cela permet aux agences de devenir opÃ©rationnelles rapidement sur la plateforme.

\[ \] Check-list de profil : Mettre en place une check-list de complÃ©tion du profil utilisateur (client ou agence). Par exemple, pour un client : indiquer les Ã©tapes Â« Ajouter votre permis de conduire Â» (KYC), Â« Ajouter une photo de profil Â», etc., avec une barre de progression. Pour une agence : Â« VÃ©rifier votre email Â», Â« Renseigner RIB pour paiements Â» (si applicable), etc. Cette check-list peut Ãªtre affichÃ©e sur le tableau de bord tant quâ€™elle nâ€™est pas complÃ¨te, afin dâ€™encourager lâ€™utilisateur Ã  finaliser son profil pour une expÃ©rience optimale.

\[ \] Aide et FAQ intÃ©grÃ©es : Inclure dans lâ€™UI des points dâ€™interrogation ou infobulles sur les Ã©lÃ©ments potentiellement complexes. Par exemple, sur le montant de la caution : une petite info-bulle â€œLa caution est gÃ©rÃ©e directement par lâ€™agence lors du retrait du vÃ©hicule, mais est affichÃ©e ici pour informationâ€. De mÃªme, expliquer lâ€™acompte en ligne dans le formulaire de rÃ©servation (â€œPourquoi un acompte de 10% ? Pour garantir votre rÃ©servation et rÃ©munÃ©rer la plateformeâ€). Ces micro-textes dâ€™onboarding contextualisÃ© amÃ©liorent la comprÃ©hension sans nÃ©cessiter de parcourir une documentation externe.

Phase F7 â€“ Internationalisation (i18n)

\[ \] Mettre en place le framework i18n : Installer une librairie de gestion de lâ€™internationalisation adaptÃ©e Ã  Next.js (par ex. next-i18next ou le systÃ¨me i18n intÃ©grÃ© de Next 13). Configurer les langues supportÃ©es dÃ¨s le dÃ©part, notamment FranÃ§ais (par dÃ©faut) et prÃ©parer lâ€™Anglais. Envisager lâ€™Arabe pour le public local (mÃªme si peut-Ãªtre dans un second temps, prÃ©voir lâ€™infrastructure technique pour gÃ©rer une langue RTL).

\[ \] Externaliser les libellÃ©s : Remplacer tous les textes statiques de lâ€™interface par des clÃ©s de traduction. Organiser les fichiers de langue (JSON ou autres) par page ou par composant. Traduire dâ€™abord lâ€™essentiel en franÃ§ais et anglais. Exemple : { "home": { "title": "Location de voiture en AlgÃ©rie simplifiÃ©e" } } etc. Sâ€™assurer que toutes les chaÃ®nes affichÃ©es Ã  lâ€™utilisateur passent par le systÃ¨me de traduction (y compris les messages dâ€™erreur, validations de formulaire, etc.).

\[ \] Gestion du changement de langue : IntÃ©grer un sÃ©lecteur de langue dans lâ€™UI (par exemple un menu avec drapeau ou code langue dans le header ou le footer). Permettre Ã  lâ€™utilisateur de changer de langue Ã  tout moment, et appliquer ce changement immÃ©diatement (stockage du choix dans un cookie ou localStorage pour le retenir).

\[ \] Support du texte RTL : Si lâ€™arabe doit Ãªtre supportÃ©, adapter le CSS pour le sens de lecture de droite Ã  gauche. TailwindCSS propose des utilitaires RTL ou on peut ajouter \[dir="rtl"\] en haut du DOM. Tester que lâ€™interface reste cohÃ©rente en arabe (alignements inversÃ©s, etc.). MÃªme si la traduction arabe nâ€™est pas faite tout de suite, prÃ©parer le terrain technique Ã©vite des refontes plus tard.

Phase F8 â€“ AccessibilitÃ© (a11y)

\[ \] SÃ©mantique HTML correcte : VÃ©rifier que les pages utilisent les Ã©lÃ©ments HTML appropriÃ©s â€“ par exemple les titres (\<h1\>â€¦\<h6\>) ordonnÃ©s correctement, les listes, les formulaires avec leurs \<label\> associÃ©s aux \<input\> etc. Une bonne sÃ©mantique facilite grandement la navigation pour les technologies dâ€™assistance (lecteurs dâ€™Ã©cran).

\[ \] Attributs ARIA et rÃ´les : Pour les composants complexes (ex: modales, carrousels de photos, menus dÃ©roulants personnalisÃ©s), ajouter les attributs ARIA nÃ©cessaires (aria-label, aria-modal, rÃ´les de navigation, rÃ©gion, etc.) afin de dÃ©crire lâ€™intention de ces composants aux utilisateurs malvoyants. Sâ€™assurer que les formulaires annoncent clairement les erreurs (ex: aria-invalid et messages dâ€™aide).

\[ \] Navigation clavier fluide : Tester que lâ€™on peut tabuler Ã  travers tous les Ã©lÃ©ments interactifs de maniÃ¨re logique. ImplÃ©menter des gestionnaires dâ€™Ã©vÃ©nements clavier pour les composants custom (ex: fermer une modal avec Esc, naviguer avec flÃ¨ches dans un slider, appuyer sur EntrÃ©e pour un bouton personnalisÃ©). Sâ€™assurer que le focus est visible (outline Tailwind ou personnalisÃ©e) et bien gÃ©rÃ© (par ex., renvoyer le focus sur le bouton dâ€™ouverture dâ€™une modale quand elle se ferme).

\[ \] Contraste et alternatives : VÃ©rifier les contrastes de couleurs (utiliser des couleurs suffisamment contrastÃ©es pour le texte selon WCAG AA). Fournir des alternatives textuelles pour toutes les images importantes ( attribut alt descriptif sur les \<img\> des vÃ©hicules, logos, etc.). Si des vidÃ©os ou audios Ã©taient ajoutÃ©s, prÃ©voir des sous-titres ou transcriptions. Ces mesures assurent que le site est utilisable par le plus grand nombre.

\[ \] Audit accessibilitÃ© : Utiliser des outils dâ€™audit comme Lighthouse (onglet AccessibilitÃ©) ou axe DevTools pour dÃ©tecter dâ€™Ã©ventuels problÃ¨mes (Ã©lÃ©ments non accessibles via clavier, contrastes insuffisants, labels manquantsâ€¦). Corriger les points soulevÃ©s afin dâ€™atteindre une conformitÃ© minimale AA.

Phase F9 â€“ Micro-Interactions & Finitions UX

\[ \] Feedback visuel sur les actions : Ajouter des micro-animations pour rÃ©compenser lâ€™interaction de lâ€™utilisateur. Par ex., lorsquâ€™un utilisateur clique sur â€œRechercherâ€ ou â€œRÃ©serverâ€, changer le texte du bouton en â€œChargementâ€¦â€ avec un spinner, dÃ©sactiver temporairement pour Ã©viter les double-clics, puis afficher un check âœ… ou un message de succÃ¨s en cas de rÃ©ussite.

\[ \] Transitions et animations subtiles : ImplÃ©menter des transitions douces entre les pages et les Ã©tats. Par exemple, lors du passage de la page de rÃ©sultats Ã  la page dÃ©tail, faire un lÃ©ger fondu ou une animation de slide pour rendre la navigation plus fluide. Utiliser les capacitÃ©s de Next.js (transition de routes) ou des librairies comme Framer Motion pour chorÃ©graphier ces changements sans trop alourdir lâ€™application.

\[ \] Mises en Ã©vidence au survol : Sâ€™assurer que chaque Ã©lÃ©ment cliquable (boutons, cartes de vÃ©hicule, liens) a un Ã©tat hover/focus distinctif (changement de couleur, lÃ©gÃ¨re Ã©lÃ©vation de carte, soulignement, etc.). Ces micro-interactions donnent une sensation de rÃ©activitÃ© et aident lâ€™utilisateur Ã  comprendre quâ€™un Ã©lÃ©ment est interactif.

\[ \] Notifications et erreurs animÃ©es : PlutÃ´t quâ€™une apparition brutale, faire apparaÃ®tre les messages dâ€™alerte/erreur avec un lÃ©ger glissement ou fade-in. Par exemple, si une erreur survient dans un formulaire, afficher le message dâ€™erreur avec une transition (et Ã©ventuellement une petite secousse du champ en erreur pour attirer lâ€™attention). De mÃªme pour une notification de succÃ¨s en haut de lâ€™Ã©cran, la faire glisser depuis le haut et disparaÃ®tre aprÃ¨s quelques secondes en fade-out.

\[ \] Optimisation des performances perÃ§ues : Utiliser les micro-interactions intelligemment pour masquer les temps de chargement. Par exemple, charger progressivement les images (flou puis net â€“ technique du blur-up), afficher des squelettes de contenu (loading skeletons) pendant les appels API afin que lâ€™utilisateur ne voie pas un Ã©cran vide. Cela amÃ©liore la perception de vitesse et la qualitÃ© perÃ§ue de lâ€™application, Ã©tape finale avant la mise en production.

Phase F10 â€“ Tests Finals & DÃ©ploiement Front (en parallÃ¨le du backend)

\[ \] Tests multi-navigateurs et responsivitÃ© : Passer lâ€™application en revue sur les principaux navigateurs (Chrome, Firefox, Safari, Edge) et devices (mobile Android/iOS, tablettes, petits Ã©crans) pour vÃ©rifier quâ€™aucun Ã©lÃ©ment vital nâ€™est cassÃ©. Ajuster les styles CSS/Tailwind si nÃ©cessaire pour corriger les problÃ¨mes responsive.

\[ \] Optimisation et build de production : GÃ©nÃ©rer un build de production (next build) et vÃ©rifier les performances avec Lighthouse. Optimiser si besoin : activer le lazy-loading des images Next.js, vÃ©rifier que le tree-shaking Ã©limine le code mort, analyser le bundle (avec next-bundle-analyzer) pour traquer les dÃ©pendances trop lourdes. Sâ€™assurer que les temps de chargement initiaux et la taille des pages sont acceptables mÃªme sur connexion lente.

\[ \] DÃ©ploiement continu du frontend : PrÃ©parer le dÃ©ploiement du site web. Si hÃ©bergÃ© sur Vercel (solution recommandÃ©e pour Next.js), connecter le repo pour dÃ©ploiement auto Ã  chaque push sur branche principale. Sinon, dÃ©ployer lâ€™app via Docker ou sur un hÃ©bergement web (gÃ©nÃ©rer les pages statiques ou lancer en mode serveur Node pour SSR). Configurer le nom de domaine et les certificats SSL. AprÃ¨s dÃ©ploiement, effectuer une ultime recette (vÃ©rification) sur lâ€™environnement en ligne pour valider que tout fonctionne (y compris les appels API vers le backend dÃ©ployÃ©).

ğŸ—ï¸ Architecture Fullstack Actuelle du Projet

Stack Technologique : Le backend est dÃ©veloppÃ© avec NestJS (framework Node.js en TypeScript) couplÃ© Ã  Prisma (ORM TypeScript) pour gÃ©rer une base de donnÃ©es PostgreSQL. Le frontend est une application Next.js (React & TypeScript) stylÃ©e avec TailwindCSS pour une interface responsive moderne. Cette stack JS fullstack facilite la cohÃ©rence entre front et back (langage TypeScript cÃ´tÃ© client et serveur) et offre performance ainsi que maintenabilitÃ©. Des outils tiers complÃ¨tent lâ€™architecture, par ex. Passport JWT pour lâ€™authentification sÃ©curisÃ©e, Stripe ou API Satim pour les paiements en ligne, et Docker pour la containerisation et le dÃ©ploiement.

Structure des Dossiers : Le code backend NestJS adopte une structure modulaire classique : un dossier src/ contenant diffÃ©rents modules (par domaine mÃ©tier, ex: auth/, vehicules/, reservations/, etc.), chacun avec ses contrÃ´leurs, services, entitÃ©s/DTO. Un fichier main.ts Ã  la racine initialise lâ€™application Nest (et la config globale, ex: CORS, validation pipe). Le fichier schema.prisma (Ã  la racine du projet ou dans prisma/) dÃ©crit le modÃ¨le de donnÃ©es, et les migrations sont dans prisma/migrations/. CÃ´tÃ© frontend Next.js, on retrouve un dossier pages/ (ou app/ selon la version) qui contient les pages routÃ©es, un dossier components/ pour les composants rÃ©utilisables, un dossier styles/ pour les feuilles CSS globales (notamment lâ€™import Tailwind). Des dossiers additionnels comme hooks/ pour les hooks custom, context/ pour les contextes React (ex: AuthProvider), et public/ pour les ressources statiques (images, faviconâ€¦) complÃ¨tent lâ€™organisation. Cette sÃ©paration claire front/back permet Ã  chaque Ã©quipe de travailler en parallÃ¨le tout en maintenant une interface commune via l'API.

Communication Frontendâ€“Backend : Lâ€™Ã©change de donnÃ©es se fait via une API REST sÃ©curisÃ©e. Le backend NestJS expose des endpoints RESTful (gÃ©nÃ©ralement sous forme dâ€™URL commenÃ§ant par /api/â€¦ par ressource, par ex. /api/vehicules, /api/reservationsâ€¦). Le format dâ€™Ã©change est du JSON pour les requÃªtes et rÃ©ponses, standard et facilement manipulable cÃ´tÃ© front. Pour les appels sensibles ou modifiant des donnÃ©es, le frontend inclut dans les requÃªtes un jeton JWT dans le header HTTP Authorization: Bearer \<token\> afin que le backend puisse authentifier et autoriser lâ€™utilisateur. Le processus type : le client front obtient un JWT lors du login ou inscription via un appel Ã  /api/auth/login (rÃ©ponse contenant le token), le stocke de maniÃ¨re sÃ©curisÃ©e (cookie HttpOnly de prÃ©fÃ©rence pour Ã©viter le XSS) puis lâ€™envoie automatiquement Ã  chaque appel suivant. Ainsi, les routes protÃ©gÃ©es (rÃ©servation, ajout vÃ©hiculeâ€¦) ne peuvent Ãªtre utilisÃ©es quâ€™avec un JWT valide. En retour, le backend envoie les donnÃ©es demandÃ©es ou des codes dâ€™erreur JSON (avec message explicatif) que le front traitera pour afficher les bons feedbacks Ã  lâ€™utilisateur. Ã€ noter que NestJS intÃ¨gre Swagger, ce qui permet au frontend (et aux outils dâ€™IA dans lâ€™IDE) de consulter le contrat dâ€™API (endpoints, formats) pendant le dÃ©veloppement pour rÃ©duire les malentendus.

Environnement de DÃ©veloppement : Le projet utilise un fichier de configuration .env pour stocker les variables sensibles et spÃ©cifiques aux environnements. Par exemple : la connexion BDD (URL PostgreSQL), la SECRET\_KEY JWT, les clÃ©s dâ€™API tierces (service de paiement, service dâ€™envoi dâ€™emails/SMS), etc. Ces variables sont chargÃ©es au dÃ©marrage de lâ€™app backend (via @nestjs/config) et cÃ´tÃ© frontend Next via le mÃ©canisme de variables publiques NEXT\_PUBLIC\_.... En dÃ©veloppement local, on exÃ©cute souvent le backend NestJS avec npm run start:dev (via Nodemon pour rechargement Ã  chaud) et le frontend Next.js avec npm run dev. Un fichier docker-compose.yml est disponible pour lancer facilement les services nÃ©cessaires en local, notamment une instance PostgreSQL pour la base de donnÃ©es (et Ã©ventuellement des services comme MinIO pour stocker les fichiers si utilisÃ©, ou un Redis si besoin futur de cache). Swagger UI est accessible en dev sur une route (ex: /api-docs) pour tester rapidement les appels backend. Pour la collaboration, le code est versionnÃ© sur Git (hÃ©bergÃ© sur GitHub/GitLab), et des pipelines CI exÃ©cutent tests et lints Ã  chaque merge. En ce qui concerne Docker, chaque composant (API, frontend) a son image de dÃ©ploiement, ce qui permet de dÃ©ployer dans nâ€™importe quel environnement supportant Docker. Le dÃ©ploiement de la version officielle se fera idÃ©alement via une chaÃ®ne CI/CD : par exemple, push des images sur un registre (Docker Hub ou privÃ©) et dÃ©ploiement sur un serveur cloud. Le choix de Flutter pour lâ€™application mobile signifie quâ€™Ã  terme, le backend actuel servira aussi lâ€™API aux apps Android/iOS, sans modifications majeures (le frontend web et mobile consommeront les mÃªmes endpoints REST).

ğŸ“± Version Mobile (Application) â€“ Note de Planification

La version mobile native du service EkriMenDarek sera abordÃ©e aprÃ¨s la mise en ligne et la stabilisation du site web. Il sâ€™agira dâ€™un projet sÃ©parÃ©, possiblement dÃ©veloppÃ© avec Flutter (technologie multiplateforme Android/iOS) ou Ã©quivalent, afin de proposer une application mobile performante tout en rÃ©utilisant les logiques mÃ©tier existantes via lâ€™API. Ce dÃ©veloppement mobile fera lâ€™objet dâ€™un livrable Ã  part, une fois le backend et le site web dÃ©ployÃ©s officiellement. Lâ€™objectif est dâ€™assurer dâ€™abord le succÃ¨s de la plateforme web, puis dâ€™Ã©tendre lâ€™expÃ©rience utilisateur sur mobile sans dupliquer les efforts cÃ´tÃ© serveur. Ainsi, toutes les fonctionnalitÃ©s clÃ©s (recherche, rÃ©servation, paiement, etc.) seront disponibles sur lâ€™application, consommant lâ€™API dÃ©jÃ  en place, et offrant une expÃ©rience optimisÃ©e pour smartphones. En rÃ©sumÃ©, prioritÃ© au web pour le lancement, et la phase mobile viendra renforcer lâ€™offre une fois le produit web mÃ»r et validÃ© par le marchÃ©.