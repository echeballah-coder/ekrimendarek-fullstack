**Optimisation de l’Architecture Fullstack du projet EkriMenDarek**

Dans cette section, nous allons améliorer et perfectionner l’architecture complète (frontend & backend) du projet EkriMenDarek en nous basant sur le cahier des charges fourni. Nous procéderons de manière itérative, pas à pas, en intégrant le frontend déjà défini ainsi que la couche backend et les spécificités techniques du marché algérien. Chaque étape correspond à une amélioration progressive de l’architecture, pour aboutir à une solution robuste, scalable et adaptée aux contraintes locales (paiement en cash, caution physique, agents sur le terrain). L’objectif final est de fournir une architecture professionnelle prête à être développée en équipe sur GitHub.

***Étape 1 : Organisation Générale & Structure des Dossiers (Frontend/Backend)***

Dans un premier temps, nous définissons la structure globale du projet en séparant clairement le frontend et le backend. Le projet peut être organisé soit en monorepo (e.g. via Nx) pour regrouper front et back dans un même dépôt, soit en dépôts distincts. Dans tous les cas, on veille à ce que chaque partie ait une arborescence de dossiers claire et maintenable:

Frontend (existant) : On conserve la stack définie (par ex. application web en Next.js/React ou Angular, et application mobile Flutter pour iOS/Android). La structure typique comprendra des dossiers pour les pages (ou components), les services API, les assets (images, styles) et les utils. Par exemple, pour une application Angular, on pourrait avoir un dossier app/ avec des sous-dossiers par fonctionnalité (recherche, réservation, profil, etc.), et pour Next.js des dossiers par page route. On s’assure d’organiser le code du frontend par features modulaires (lazy loading des modules/pages) afin de faciliter l’évolution et le travail en équipe. Par ailleurs, on prévoit un dossier shared/ ou common/ pour les composants réutilisables et les utilitaires (p. ex. composants d’UI communs, fonctions de formatage, etc.). Enfin, on prépare le frontend à consommer l’API backend REST (v1) définie plus loin.

Backend (NestJS) : On initialise un projet NestJS (nest new). La structure par défaut de Nest est déjà modulaire et organisée. On crée un dossier src/modules/ où chaque module métier aura son propre sous-dossier (User, Agency, Vehicle, Booking, Payment, KYC, Review, etc.). Chaque module contient son controller (endpoints REST), son service (logique métier) et éventuellement ses modèles/dtos. Cette isolation par domaine suit les bonnes pratiques NestJS pour une application modulable et maintenable. On ajoute aussi des dossiers transverses : src/common/ (middlewares, pipes et guards partagés), src/config/ (configuration par environnement), et src/prisma/ (si on utilise Prisma pour la DB, voir étape 3). L’organisation peut suivre un style DDD (Domain-Driven Design) où chaque module représente un agrégat du domaine (par ex. le module Booking importe les services User et Vehicle). Ainsi, NestJS nous permet de découper l’application en parties logiques (via des modules) pour mieux structurer le code.

En résumé, cette première étape met en place une base de code propre et structurée, facilitant la collaboration. Le frontend reste séparé mais synchronisé avec le backend, et on prévoit un couplage via des contrats clairs (DTOS, interfaces d’API). Ces fondations posées, on peut enrichir progressivement chaque couche.

***Étape 2 : Modules Backend NestJS pour les Domaines Clés***

En suivant le cahier des charges, nous identifions les entités clés du domaine : Utilisateur (User), Agence (Agency), Véhicule (Vehicle), Réservation (Booking), Paiement (Payment), KYC (vérif. identité) et Avis/Notation (Review). Chacune de ces entités correspond à un module NestJS dédié, afin d’encapsuler la logique et les données relatives :

Module User : Gère les comptes clients (et potentiellement sert de base aux comptes Agence et Admin). Il inclut l’inscription, la connexion, la mise à jour de profil, etc. Un utilisateur a des attributs de base (nom, email, téléphone, etc.) et un rôle (client, agence ou admin). On peut modéliser un champ role ou un enum dans la DB. Ce module exposera des services de gestion des utilisateurs, utilisés par le module Auth (JWT) et par d’autres modules (p. ex. le module Booking pour associer une réservation à un utilisateur).

Module Agency : Représente les agences de location (B2B). Chaque agence peut être gérée par un ou plusieurs utilisateurs avec rôle Agency. On stocke les infos d’agence (nom commercial, adresse, contact, éventuellement des documents d’enregistrement si besoin). Ce module gère aussi l’interface back-office pour l’agence : activation/désactivation de voitures, consultation des réservations reçues, etc. (voir étape API). Une agence a une relation one-to-many avec ses véhicules. Dans NestJS, le module Agency importe le module User (pour lier une agence à son compte utilisateur référent) et le module Vehicle (ou du moins son service) pour gérer la flotte.

Module Vehicle : Gère les véhicules disponibles à la location. Chaque véhicule est rattaché à une Agence (agencyId). Les données incluent modèle, marque, année, type de boîte (Auto/Manuel), carburant (Essence/GPL/Diesel), tarif par jour, montant de caution requis (garantie) et autres exigences spécifiques de l’agence. On veille à inclure les attributs spécifiques au marché algérien : par exemple, la caution exigée doit être stockée et affichée clairement dans la fiche véhicule. On stocke aussi une indication de disponibilité (disponible, en location, hors service). Ce module fournit des endpoints de recherche et de fiche détail pour les véhicules (voir étape 4). Il gère aussi l’upload des photos des véhicules (voir étape 9). On s’assure que l’entité véhicule supporte les filtres requis (boîte, carburant, etc.) pour la recherche.

Module Booking : Cœur du système de réservation. Une réservation lie un utilisateur (client) à un véhicule (via l’agence propriétaire) pour une certaine période. Le module Booking gère la création d’une nouvelle réservation, son état (en attente de validation agence, confirmée, annulée, terminée, etc.) et les interactions liées (confirmation agence, annulation client, etc.). Lorsqu’un client initie une réservation, on crée un enregistrement en attente de paiement. Une fois l’acompte payé (voir Payment), la réservation passe en en attente validation. L’agence a alors un délai (2 heures prévu) pour valider ou refuser. S’il y a validation (manuelle ou auto), la réservation devient confirmée et un voucher est émis. Le module Booking importe donc le module Payment (pour vérifier le paiement de l’acompte) et le module Vehicle (pour vérifier disponibilité et bloquer le véhicule sur les dates demandées). Il peut aussi notifier le module Notification/WhatsApp une fois confirmée (interopérabilité).

Module Payment : Traite tout ce qui est paiement en ligne de l’acompte (10-15% du total). Ce module intègre l’API de paiement locale (CIB/Edahabia via une passerelle type Satim ou service comme Chargily). Il gère la création de la transaction (par ex. génération d’un lien de paiement ou appel API) et le webhook de retour pour mettre à jour le statut du paiement une fois l’utilisateur débité (voir étape 5 sur intégrations). Une fois informé d’un paiement success, le module Payment met à jour l’entité Booking associée (paiement reçu) et déclenche les actions post-paiement (envoi de confirmation, etc.). On stocke les enregistrements de paiements (montant, méthode, identifiant transaction, état succès/échec) afin d’avoir un suivi. À noter qu’en Algérie, le paiement en ligne portera sur un acompte de \~10-15% du montant, le reste étant payé en cash à l’agence lors de la récupération du véhicule. Ce modèle hybride garantit un revenu immédiat pour la plateforme et engage le client.

Module KYC : Gère la vérification d’identité des utilisateurs. Le cahier des charges prévoit un KYC léger à l’inscription ou lors de la première réservation : l’utilisateur doit uploader son permis de conduire et un selfie. Ce module s’occupe de stocker ces documents de manière sécurisée, et idéalement d’automatiser des contrôles : par exemple, utiliser un système OCR pour lire les informations du permis (nom, date de délivrance) afin de pré-remplir le profil et vérifier que l’ancienneté du permis dépasse 2 ans. Une fois les documents vérifiés (automatiquement ou manuellement en back-office), on marque l’utilisateur comme “KYC vérifié”. Ce statut peut être exigé avant de pouvoir finaliser une réservation, afin de réduire la fraude. Ce module pourrait aussi comprendre la gestion d’une “liste rouge” partagée des clients frauduleux ou indésirables, comme évoqué dans les specs (par exemple si une agence signale un client pour vol ou dégradation, l’information est partagée). Dans un premier temps, cette blacklist peut être un simple attribut ou table reliant des utilisateurs à un flag “blacklisté”, consultable par les agences (fonctionnalité premium).

Module Review : Implemente le système de notation mutuelle prévu. Après chaque location complétée, le client peut noter l’agence/le véhicule (ex : 1 à 5 étoiles \+ commentaire), et l’agence peut noter le client ou au moins le “flagger” en interne. On crée une entité Review reliée à une réservation (ou à un véhicule et un utilisateur). Pour la notation publique, on associe une review du client vers l’agence/véhicule (visible dans la fiche véhicule pour rassurer les futurs clients). Pour la notation interne agence→client, on peut stocker cela soit dans Review avec un champ rôle/type, soit séparément (puisque c’est interne, cela pourrait alimenter la blacklist plutôt qu’une note). Dans tous les cas, le module Review fournit des endpoints pour créer et lire ces avis. Cela permet d’instaurer la confiance par la transparence, un élément clé de la proposition de valeur.

Chaque module NestJS est découplé mais interconnecté via l’injection de dépendances. On utilise les imports de modules Nest pour que, par exemple, le BookingModule puisse utiliser le UsersService (depuis UsersModule) et le VehiclesService (depuis VehicleModule), etc. On veille à exporter les services nécessaires dans les modules correspondants. Cette organisation modulaire facilitera le travail parallèle des développeurs (chacun pouvant se concentrer sur un module) et assure une évolutivité de l’application.

***Étape 3 : Schéma de Base de Données Aligné avec Prisma***

Après avoir défini les modules, on concrétise la conception de la base de données. Prisma étant l’ORM choisi, on décrira le schéma dans schema.prisma avec les modèles correspondants aux entités identifiées. On vise un schéma propre, normalisé et cohérent avec les besoins. Voici une proposition de modèle de données :

User (table users) : contient les utilisateurs (clients, agences et admins dans la même table, distingués par un champ role). Champs principaux : id (UUID ou auto-inc int), name, email (unique), phone, passwordHash, role (enum: CLIENT, AGENCY, ADMIN), createdAt, etc. Pour le KYC, on peut ajouter des champs comme licenseNumber, licenseImageURL, selfieURL, isVerified (bool) – à moins de les mettre dans une table séparée kyc reliée par userId. Ici, une table séparée KYC pourrait stocker les URLs des documents et un statut de vérification, ce qui rend la gestion plus flexible (un admin peut valider/refuser et éventuellement stocker une raison). Relation : un utilisateur peut avoir 0 ou 1 Agence associée (s’il a le rôle AGENCY).

Agency (table agencies) : représente les agences de location. Champs : id, name (nom commercial), address (ou siège social), wilaya/commune (zone de couverture), éventuellement registrationNumber (numéro registre commerce si disponible), verified (bool, si l’agence a été validée par l’équipe avant d’apparaître). Relation : ownerId référencé vers users(id) pour l’utilisateur gérant l’agence. On peut aussi prévoir une relation inverse où un user de rôle Agency a un champ agencyId. Une agence aura plusieurs Vehicle en relation one-to-many.

Vehicle (table vehicles) : représente un véhicule à louer. Champs : id, agencyId (FK vers agencies), make (marque, ex. Renault), model (Clio 4), year, transmission (enum: AUTO/MANUAL), fuel (enum: ESSENCE/GPL/DIESEL), pricePerDay, depositAmount (caution exigée, en DZD), requirements (texte libre pour conditions spécifiques de l’agence, ex. "Permis \>2 ans", "Pas de permis probatoire"), status (DISPONIBLE, INDISPONIBLE, etc.). On stocke aussi un champ images (qui peut être géré via une table séparée vehicle\_photos pour lister plusieurs URLs de photos). Relations : Vehicle → Agency (N à 1). Éventuellement, on peut lier à un Category (berline, utilitaire… si on catégorise, mais pas obligatoire initialement). Le champ depositAmount est crucial pour informer le client de la caution en espèces qu’il devra laisser. Ce schéma reflète les filtres et critères locaux : par exemple on pourra requêter par transmission, carburant ou plafond de caution.

Booking (table bookings) : chaque réservation. Champs : id, userId (client ayant réservé), vehicleId, agencyId (redondant pour faciliter certaines requêtes, ou dérivé via vehicle-\>agency), startDate, endDate, totalPrice (calculé lors de la réservation pour la durée), depositAmount (montant de l’acompte payé en ligne, typiquement \= totalPrice \* 10-15%), status (PENDING\_PAYMENT, PENDING\_CONFIRMATION, CONFIRMED, CANCELLED, COMPLETED, etc.), createdAt. Relations : Booking → User (N à 1), Booking → Vehicle (N à 1). Une fois une réservation confirmée, le véhicule pourrait être marqué indisponible sur la période (selon disponibilité, pour simplifier on peut supposer qu’une agence ne double-book pas le même véhicule; plus tard on pourrait avoir un calendrier d’indisponibilités). On inclut dans le booking les infos nécessaires pour l’agence : par ex, un champ driverLicenseVerified (bool) indiquant si le KYC du client est fait, afin que l’agence sache s’il a déjà fourni ses documents. Le status gère le workflow :

création initiale → PENDING\_PAYMENT (en attente que l’utilisateur paie l’acompte en ligne),

une fois paiement reçu → PENDING\_CONFIRMATION (en attente validation agence),

si agence confirme (ou auto-validation) → CONFIRMED,

si agence refuse ou timeout 2h → CANCELLED (à gérer, potentiellement remboursement de l’acompte),

après la date de fin passée, on peut marquer COMPLETED (ce qui permet de laisser un avis).

Ce modèle permet de tracer chaque étape du parcours de réservation.

Payment (table payments) : journalise les paiements en ligne. Champs : id, bookingId (FK vers booking), amount, currency (DZD), method (CIB, EDDAHABIA, BARIDIMOB, etc.), provider (SATIM, Chargily, etc.), status (SUCCESS, FAILED), transactionRef (référence de la transaction retournée par le prestataire), paidAt. En pratique, comme on encaisse uniquement l’acompte via la plateforme, chaque réservation confirmée devrait avoir un enregistrement Payment réussi correspondant à l’acompte (ex: 15% du total). Relation : Payment → Booking (N à 1). S’il y avait plusieurs paiements (ex: permettre de payer la totalité en ligne ou paiements échelonnés), on pourrait avoir plusieurs records liés à une réservation, mais dans le modèle actuel un seul paiement est attendu par réservation. Ce tableau facilite le suivi de la commission de la plateforme, puisque cette commission correspond précisément aux paiements reçus en ligne. On pourra ainsi calculer le revenu généré sur une période (somme de payments.amount).

Review (table reviews) : stocke les avis et notations. Il peut être utile de avoir deux types d’avis (client-\>agence et agence-\>client). On peut distinguer par un champ byRole (CLIENT ou AGENCY) ou avoir deux tables séparées. Pour simplifier, on crée une table unique avec : id, bookingId, authorId (qui peut être userId de l’auteur de l’avis), targetAgencyId (nul si c’est un avis agence-\>client), targetUserId (nul si avis client-\>agence), rating (étoiles 1-5, null si agence ne donne pas de note mais juste un flag), comment (texte éventuel), createdAt. Pour un avis client-\>agence, authorId \= user (client), targetAgencyId \= agence concernée (via booking), et on peut recouper que booking.userId=authorId et booking.agencyId=targetAgencyId pour cohérence. Pour un avis agence-\>client (interne), authorId \= user de l’agence, targetUserId \= client. L’agence pourrait ne pas donner d’« étoiles » mais plutôt cocher des comportements (retard, problème, etc.), qu’on peut stocker dans comment ou prévoir un champ structure. Une implémentation plus simple pour la blacklist mutualisée : si une agence veut signaler un client, on peut créer une review agence-\>client avec, par exemple, rating=null et un champ flag=true. Les autres agences pourraient consulter ces entrées. C’est une approche rudimentaire mais elle permet d’utiliser ce même mécanisme d’avis pour alimenter la liste rouge des mauvais clients.

Autres tables : potentiellement photos (id, vehicleId, url, isVerified) pour stocker plusieurs photos par véhicule. Cependant, Prisma permet aussi un champ de type String\[\] pour stocker une liste d’URLs d’images directement dans le modèle Vehicle (selon préférences). Néanmoins, avoir une table séparée pour photos permet éventuellement de lier des métadonnées (ex: qui a uploadé, date de validation, etc.). On prévoira également une table admins ou on utilisera users avec role ADMIN pour gérer l’administration de la plateforme (validation agences, modération avis, etc.).

Ce schéma est aligné avec Prisma : on définit ces relations (1-n, etc.), on utilise les migrations Prisma pour créer le DB. On optera probablement pour une base de données relationnelle (PostgreSQL ou MySQL) pour la cohérence des relations. Prisma permettra de générer les classes/DTOs correspondants en TypeScript, que l’on peut directement utiliser dans les services NestJS.

On fait attention aux contraintes d’intégrité et aux particularités locales : par exemple, pour ne pas perdre la commission, on impose via logique applicative qu’une réservation confirmée doit avoir un Payment réussi associé (sinon on ne la considère pas confirmée). De même, on ne supprimera pas en cascade les enregistrements importants – par exemple, si un véhicule est supprimé, on peut conserver les bookings liés pour l’historique (on pourrait utiliser un champ softDelete ou bien interdire la suppression s’il y a des bookings futurs). On peut affiner ces règles selon les besoins métier.

***Étape 4 : API RESTful v1 – Endpoints pour chaque Parcours Utilisateur***

Avec le schéma et les modules en place, on définit les endpoints REST (version 1\) nécessaires pour couvrir les parcours utilisateurs décrits dans le cahier des charges. Nous suivrons une convention REST claire (ressources et verbes HTTP) et versionnerons l’API sous le préfixe /api/v1. Voici les principaux endpoints classés par fonctionnalité :

***1\. Parcours Client – Recherche & Réservation :***

Recherche de véhicules : GET /api/v1/vehicles – Permet de chercher des véhicules disponibles selon des critères. Paramètres possibles : location (wilaya/commune, ou coordonnées GPS si on fait géoloc automatique), dates startDate et endDate (pour filtrer ceux non loués sur la période, si on gère la disponibilité), filtres comme transmission, fuel et plage de price ou de caution. Par exemple, un client peut chercher “voitures à Alger du 1 au 10 août, boîte auto, caution \<= 50k DA”. L’endpoint retourne une liste paginée des véhicules correspondant, avec pour chaque véhicule les informations de base (modèle, prix/jour, localisation, agence) et éventuellement une indication “disponible” ou “sur demande”. SEO : on veillera à ce que ces résultats puissent aussi être accessibles via des URLs décrivant la recherche (pour indexation, ex: /vehicles?wilaya=Alger\&fuel=ESSENCE...). (Note: pour MVP, on peut simplifier en listant tous les véhicules d’une wilaya sans vérif de calendrier, et gérer la confirmation via l’agence).

Fiche véhicule : GET /api/v1/vehicles/{vehicleId} – Détail complet d’un véhicule sélectionné. Doit inclure : photos, description, caractéristiques (transmission, carburant,...), montant de caution exigé par l’agence, conditions spécifiques (issues de Vehicle.requirements, ex: âge minimum, etc.) et éventuellement note moyenne des avis précédents. On inclut aussi des infos sur l’agence (nom, note globale, nombre de locations, etc.) pour la confiance. Cet endpoint est accessible sans authentification (ou avec auth optionnelle si on veut signaler si l’utilisateur a déjà réservé ce véhicule etc.).

Création d’une réservation : POST /api/v1/bookings – Le client authentifié initie une demande de réservation. Dans le corps on attend : vehicleId, startDate, endDate (période choisie) et peut-être quelques détails comme nombre de passagers (si pertinent) ou options. Le backend vérifie que le véhicule est disponible (et éventuellement que l’utilisateur est KYC vérifié s’il faut) puis crée un enregistrement Booking avec status PENDING\_PAYMENT. La réponse doit indiquer la suite du processus de paiement. Il y a plusieurs approches :

Soit on intègre directement le paiement dans cette étape (par ex, en appelant le service Payment qui renvoie un lien de paiement à l’utilisateur). Dans ce cas, la réponse pourrait contenir une URL de redirection vers la page de paiement CIB/Edahabia (ou un formulaire) générée via l’API de paiement.

Ou bien le frontend appelle ensuite un endpoint dédié au paiement (voir ci-dessous).

Pour l’expérience utilisateur, on peut enchaîner directement. Supposons que le paiement soit externalisé (via une page de la banque ou un checkout pop-up) : alors POST /bookings renvoie un bookingId et peut-être un token/URL de transaction. Le frontend redirige l’utilisateur vers la page de paiement ou ouvre le SDK de paiement. Une fois le paiement effectué, on recevra un webhook (voir Payment plus bas) puis on redirigera le client vers la confirmation.

Webhook de paiement (callback) : POST /api/v1/payments/webhook – Endpoint appelé par le fournisseur de paiement (CIB/Chargily) une fois la transaction effectuée. Il valide la signature de la requête, récupère l’ID de commande/transaction, puis :

Vérifie le statut du paiement (succès ou échec) via les données reçues ou en appelant l’API du fournisseur si nécessaire.

Si paiement réussi, il met à jour le Payment record correspondant (status SUCCESS) et le Booking associé : on passe le booking en PENDING\_CONFIRMATION (acompte payé, en attente agence). On déclenche alors l’envoi du voucher par email et WhatsApp au client et une notification à l’agence.

Si paiement échoué, on met à jour Payment (FAILED) et éventuellement on annule la réservation (Booking status CANCELLED) en informant le client.

Remarque: ce webhook doit être accessible sans authent (externe), mais avec une sécurité (vérification de signature/API key du provider). C’est un endpoint critique pour ne pas manquer la confirmation de paiement.

Confirmation de réservation (Agence) : PUT /api/v1/bookings/{bookingId}/confirm – Endpoint utilisé par l’agence (authentifiée) pour accepter une réservation. Si on suit le cahier des charges, l’agence a un délai de 2h pour confirmer avant auto-validation. Ce endpoint permet au gérant de l’agence de confirmer manuellement dès qu’il voit la demande. Il ne fait effet que si le status est PENDING\_CONFIRMATION et si c’est bien le booking de son agence. En cas de confirmation, on change le status à CONFIRMED, on notifie le client (si pas déjà fait) que la réservation est confirmée et qu’il peut aller récupérer le véhicule. Si l’agence refuse (par ex véhicule finalement indisponible), on pourrait avoir un endpoint PUT /api/v1/bookings/{id}/decline ou une action sur le même endpoint avec un body “status=declined”. Un refus entraîne l’annulation du booking et possiblement le remboursement de l’acompte au client (à définir dans les CGV; le modèle préférerait éviter les refus en pénalisant l’agence). L’API peut marquer le booking CANCELLED et initier un processus de remboursement via l’API paiement (ou crédit interne si on retient l’acompte? Mais plus correct de rembourser si pas de service rendu).

Consultation des réservations client : GET /api/v1/bookings/me – Le client (auth) peut lister ses réservations passées et en cours. Cela permet de voir l’historique, les statuts (en attente, confirmée…) et d’accéder aux détails (voucher). On peut filtrer dans le query par status si besoin (ex: ?status=upcoming,past). Ce n’est pas explicitement dans le cahier des charges mais c’est standard pour une bonne UX.

Annulation de réservation (Client) : PUT /api/v1/bookings/{id}/cancel – Permet à un client d’annuler une demande ou une réservation confirmée, selon des règles (et potentiellement des frais). Étant donné que l’acompte est non-remboursable 48h avant dans les recommandations, on peut implémenter que si l’annulation est proche de la date, le client perd son acompte. Techniquement, annuler met le status à CANCELLED, libère le véhicule. Si en dehors des 48h, on pourrait rembourser l’acompte via l’API paiement (mais l’expert recommandait non-remboursable après 48h). Ce endpoint doit vérifier le timing et le status (on n’annule pas une déjà annulée ou terminée).

***2\. Parcours Agence – Back-Office*** :

Toutes les routes suivantes nécessitent une authentification avec rôle AGENCY (et idéalement appartenance à l’agence concernée). On peut les regrouper sous un prefix /api/v1/agency pour clarté, ou utiliser les mêmes endpoints que ci-dessus en filtrant par rôle (ex: GET /vehicles avec auth agency ne renvoie que ses véhicules si on passe un param ou si on a un endpoint dédié).

Inscription Agence : POST /api/v1/auth/register?role=agency – L’agence peut s’inscrire via un flux spécifique (fournir nom de l’agence, infos contact en plus du nom/email). Alternativement, on peut avoir un onboarding agence en deux étapes : d’abord créer un compte utilisateur normal puis, dans l’espace personnel, “Créer mon agence” via POST /api/v1/agencies (protégé, transforme son compte en agence). On collectera alors les infos agence nécessaires. Ce processus dépend si on veut valider manuellement les agences ou les accepter automatiquement. Vu la stratégie qualité (photos pro, etc.), on pourrait créer l’agence en status non vérifié, et un admin passera en vérifié après contrôle. Endpoint: POST /api/v1/agencies (auth requis) avec body (nom, adresse, etc.) qui crée l’entrée agence liée à l’utilisateur courant, et retourne l’agence créée.

Gestion profil agence : GET /api/v1/agencies/me pour récupérer les détails de l’agence connectée (incluant par ex le solde de commissions, ou stats), et PUT /api/v1/agencies/me pour mettre à jour certaines infos (horaires, adresse...). On limite les champs modifiables pour conserver la cohérence (pas de changement de propriétaire via cette route, etc., pour ça un admin interviendrait).

Ajout d’un véhicule : POST /api/v1/vehicles – Ajoute un nouveau véhicule dans la flotte de l’agence connectée. Le body contiendra toutes les infos du véhicule (modèle, année, etc.) et on vérifiera que l’utilisateur a le rôle agence. Une fois créé, le véhicule est associé à l’agence (via le user-\>agency relation). On peut permettre l’upload des photos dans ce même call via un form-data multi-part (images \+ JSON) ou avoir un endpoint séparé pour les photos. Peut-être plus simple : d’abord créer le véhicule (reçoit un id), puis appeler l’endpoint d’upload photo (cf. plus loin) pour envoyer les images qui seront liées au véhicule. Cela rend l’API plus modulaire et gère mieux les fichiers. À la création, par défaut le véhicule est status=DISPONIBLE et visible.

Modification d’un véhicule : PUT /api/v1/vehicles/{id} – Permet de modifier les détails d’un véhicule existant (par l’agence propriétaire seulement). Par exemple, ajuster le prix, changer le statut (disponible/indisponible). Le cahier des charges mentionne activer/désactiver une voiture en 1 clic – cela pourrait être un endpoint dédié plus simple : PATCH /api/v1/vehicles/{id}/toggle-availability qui inverse le statut Disponible/Au garage. Sinon, on passe un champ status dans le PUT. On doit vérifier l’accès (le JWT de l’agence correspond à la même agence que le véhicule).

Liste des véhicules de l’agence : GET /api/v1/agency/vehicles – Retourne tous les véhicules de l’agence connectée, pour affichage dans son tableau de bord (avec leurs statuts actuels). Ceci utilise soit le filtre sur /vehicles (ex: GET /vehicles?ownedByMe=true) ou un endpoint séparé comme indiqué.

Réservations à honorer : GET /api/v1/agency/bookings – Liste les réservations reçues pour les véhicules de l’agence. Par défaut, on peut renvoyer celles à venir (e.g. filtrer status PENDING\_CONFIRMATION et CONFIRMED). L’agence peut ainsi voir les demandes en attente (pour les valider) et son planning. Une vue calendrier est évoquée – on pourrait fournir un endpoint comme GET /api/v1/agency/calendar?month=... qui retourne les dates bloquées par des réservations confirmées, etc., mais cela peut être géré côté front en transformant la liste des bookings.

Confirmation/Refus d’une réservation : comme mentionné plus haut, l’agence utilise PUT /bookings/{id}/confirm ou /decline. Alternativement, on peut concevoir une route plus spécifique agence : PUT /agency/bookings/{id}/status avec un body status=confirmed ou declined. L’effet est le même – l’important est de sécuriser l’accès (seule l’agence propriétaire de la réservation peut la confirmer/refuser). Après 2h sans réponse, on peut auto-confirmer en coulisse (via un cron ou job planifié) pour ne pas faire attendre le client.

Blacklist / signaler un client : En version initiale, on peut ne pas exposer tout de suite cette fonctionnalité, mais si on l’inclut : POST /api/v1/agency/blacklist avec un body { clientId, reason } pour que l’agence signale un mauvais payeur par exemple. Cela créerait une entrée dans la liste rouge partagée. L’accès serait limité aux agences Premium abonnées idéalement, donc on pourrait verrouiller derrière un rôle ou un flag d’abonnement dans le JWT. La lecture de la blacklist peut être une route admin ou fournie aux agences premium : GET /api/v1/agency/blacklist pour consulter les clients blacklistés (ou mieux, lors d’une nouvelle réservation, le backend peut auto-avertir si le userId du client est dans la liste rouge). Ce genre de vérification peut être interne sans endpoint public.

***3\. Parcours Authentication & Onboarding*** :

Inscription client : POST /api/v1/auth/register – Création d’un compte utilisateur classique (CLIENT). On collecte email, password, nom, téléphone éventuellement. On peut aussi permettre l’inscription via Google/FB plus tard (pas prioritaire). Après inscription, un client peut tout de suite chercher des véhicules, mais on pourrait inciter à compléter son profil (KYC) avant de réserver.

Login : POST /api/v1/auth/login – Authentification par email+password (ou téléphone+OTP si on implémente plus tard). En cas de succès, on génère un JWT (voir étape 6\) et on le retourne dans un cookie HTTP-only pour le front web et/ou dans le body pour usage mobile. Après login, l’utilisateur a accès aux routes protégées (profil, réserver, etc.).

Logout : POST /api/v1/auth/logout – Facultatif (peut être géré client-side en supprimant le JWT cookie). Mais on peut fournir un endpoint qui invalide le token (sur front, on efface le cookie en le mettant expiré).

Profil utilisateur : GET /api/v1/users/me – Récupère les infos du profil connecté (y compris champ indiquant si KYC vérifié, etc.). PUT /api/v1/users/me – Met à jour certaines infos (adresse, téléphone…). Si l’appli nécessite vérification de numéro (envoi code SMS) ou email (lien), on aurait d’autres endpoints pour ça, mais MVP on peut s’en passer.

Upload permis/selfie (KYC) : POST /api/v1/users/me/kyc – Endpoint pour envoyer les fichiers de permis et selfie. Cela peut être un PATCH sur /users/me acceptant des fichiers, mais mieux un endpoint dédié. Le backend recevant l’image du permis pourra appeler un service OCR (voir étape 5\) pour en extraire les données et remplir le profil (ex: numéro de permis, date délivrance). Si tout est OK, on peut marquer directement isVerified=true; sinon, marquer en attente de vérification manuelle. Ce processus sécurise la plateforme contre les fraudeurs. On peut renvoyer un status (en cours, vérifié, refusé).

Swagger & documentation : Même si ce n’est pas directement une route métier, on prévoira une route pour la doc API (ex: /api/docs) servant Swagger UI, listant toutes les routes citées. On active la version globalement (prefixed v1) pour permettre d’évoluer plus tard. Chaque endpoint sera documenté avec son schéma d’entrée/sortie.

Avec ces endpoints, on couvre le parcours complet décrit dans le storyboard : Un client ouvre l’app, choisit sa wilaya, voit les voitures disponibles, remplit le formulaire avec permis, paie l’acompte, reçoit confirmation par email/WhatsApp, et l’agence s’inscrit, ajoute ses véhicules, reçoit les réservations avec acompte déjà payé, gère la caution physiquement. L’API est conçue pour supporter toutes ces étapes de bout en bout.

***Étape 5 : Intégrations Externes (WhatsApp, OCR Permis, Paiement CIB/BaridiMob)***

Pour une plateforme complète, l’architecture doit s’ouvrir à des services externes afin d’améliorer l’expérience utilisateur et respecter les usages locaux.

Envoi de confirmations via WhatsApp : En Algérie, WhatsApp est roi et plus lu que les SMS. Nous allons donc intégrer un service d’envoi de messages WhatsApp pour envoyer au client une confirmation dès qu’une réservation est confirmée. Techniquement, on peut utiliser l’API WhatsApp Business (fournie par Meta/Facebook) ou passer par Twilio WhatsApp API. Cela nécessite des credentials et l’approbation de templates de message. Dans notre cas, le message contiendra le voucher de réservation (référence, dates, véhicule, contact de l’agence, etc.). Le backend, au moment de la confirmation (soit paiement effectué \+ validation agence), appellera un service NotificationService.sendWhatsApp(userPhone, message) qui lui-même utilisera l’SDK/API du fournisseur. On peut encapsuler cela dans un module Notifications distinct pour centraliser e-mail et WhatsApp. Le cahier des charges insiste sur l’envoi du voucher par Email \+ WhatsApp plutôt que SMS, on se conformera à cela. On veillera à gérer les erreurs (si WhatsApp envoi échoue, fallback éventuel par SMS). L’architecture doit prévoir la config de ces clés API via les variables d’environnement (non hardcodées).

OCR du permis de conduire : Pour fluidifier l’onboarding, on intègre un système d’OCR (reconnaissance optique de caractères) capable de lire automatiquement les informations du permis à partir de la photo uploadée. Deux options : utiliser un service cloud (par ex. Google Vision, AWS Rekognition, ou une API locale si existante) ou un outil open-source (comme Tesseract OCR) intégré côté serveur. Une solution cloud peut offrir de meilleurs résultats sur des documents officiels. On pourra tester avec Tesseract, entraîné sur le template du permis algérien, mais pour fiabilité un service en ligne peut être préférable. Concrètement, lors de l’upload du permis (module KYC), on déclenche l’OCR : extraction du nom, date de naissance, numéro de permis, date de délivrance. Ensuite, la logique métier vérifie l’ancienneté du permis – par ex, comparer la date de délivrance à la date actuelle pour s’assurer qu’il a \>2 ans. Si le permis est trop récent (ex: \<2 ans), on peut refuser la réservation ou alerter (car certaines agences refusent les jeunes conducteurs). Ce contrôle était explicitement mentionné dans les exigences spécifiques d’agence. L’architecture doit donc prévoir ce calcul dans le module KYC ou Booking (au moment de réserver, vérifier user.isVerified et éventuellement permis \>=2 ans). L’OCR peut aussi servir à pré-remplir les champs du profil, évitant à l’utilisateur de tout taper manuellement – un plus UX.

Intégration paiement local (CIB, Edahabia, BaridiMob) : C’est un des points critiques, étant donné les spécificités algériennes. On a plusieurs choix :

L’API officielle SATIM/CIB : accepte les cartes CIB (cartes bancaires algériennes) et Edahabia (la carte postale d’Algérie Poste). Elle permet les paiements en Dinar. Cependant, son intégration est réputée lourde (documentation peu claire, délais d’obtention longs).

Les solutions tierces locales comme Chargily, SlickPay, Guiddini : ce sont des startups qui fournissent des API plus simples pour encaisser via CIB/Edahabia. Chargily par exemple propose une intégration clé en main (des SDK existent sur GitHub) et est l’une des solutions les plus utilisées après l’officielle. Ces services agissent comme intermédiaires : on leur envoie le montant, le nom du client, etc., et ils génèrent un lien de paiement ou un formulaire, gèrent l’interface de paiement et notifient par webhook. L’avantage est la facilité et un onboarding plus rapide que SATIM.

BaridiMob : c’est l’application de paiement mobile d’Algérie Poste, qui permet des transferts de compte à compte (liés aux cartes Edahabia). Intégrer BaridiMob pourrait consister à générer un QR code de paiement ou un numéro à payer. Cependant, BaridiMob n’a pas d’API publique documentée facilement, c’est souvent un transfert manuel. Pas idéal pour une UX fluide, à moins de proposer au client « envoyez X DA via BaridiMob au compte XXX et uploadez le reçu », ce qui serait trop frictif. On peut l’omettre dans un premier temps, d’autant que l’usage carte Edahabia via l’interface CIB est plus simple pour l’utilisateur.

Compte tenu de cela, on peut démarrer avec Chargily (ou similaire) pour l’acompte en ligne, tout en gardant la possibilité de passer à l’API officielle plus tard. L’architecture du module Payment sera abstraite de la plateforme spécifique : implémenter une interface PaymentProvider (avec méthodes createPayment, verifyPayment, etc.), et avoir une impl concrète pour Chargily. Ainsi, si on switch vers SATIM direct plus tard, on implémente la nouvelle interface.

Concrètement, lorsque le client initie une réservation :

Le backend appelle l’API du prestataire pour créer un paiement de X DA. Pour Chargily par exemple, on envoie le montant, une référence (id de booking), et une URL de callback (notre webhook). L’API retourne un lien de paiement unique.

On renvoie ce lien au frontend (ou on redirige automatiquement si c’est une application web SSR). Le client entre ses infos carte sur la page sécurisée du prestataire (CIB/Edahabia).

Le prestataire traite le paiement (avec OTP éventuellement). Une fois fait, il appelle notre webhook pour nous informer.

Nous confirmons côté backend et complétons le process (comme décrit plus haut).

En parallèle, on peut offrir une option de paiement Cash à la livraison (100% sur place). Cependant, cela pose le problème souligné : on risque de ne pas percevoir notre commission. L’expert conseille fortement d’exiger au moins un petit acompte en ligne (ex: 1000 DA) pour toute réservation. Nous suivrons ce conseil : l’API n’autorisera pas une réservation sans paiement, ou en tout cas poussera toujours un paiement minimal. Quitte à ce que ce soit symbolique, cela garantit un engagement du client et évite qu’on doive courir après l’argent auprès des agences.

En termes de sécurité : les pages de paiement seront hébergées par le prestataire (HTTPS). Notre backend ne stockera aucune info de carte (compliance PCI DSS). On se contentera des résultats des transactions.

À l’issue du paiement réussi, comme mentionné, on envoie email \+ WhatsApp au client. L’email contiendra peut-être un PDF de voucher. On peut générer ce PDF côté backend (librairie PDFKit ou html-pdf) contenant les détails de la réservation et des conditions (montant payé en ligne, restant dû à l’agence, caution à apporter...). Ce PDF peut être attaché à l’email et un lien peut être envoyé via WhatsApp.

Pour récapituler cette étape : on connecte l’architecture aux outils extérieurs indispensables – WhatsApp pour les notifications (meilleure délivrabilité que SMS en Algérie), OCR pour accélérer le KYC et améliorer la fiabilité (éviter les permis falsifiés), et paiement électronique local pour encaisser les acomptes (en choisissant l’approche la plus pragmatique pour démarrer, ex: Chargily qui couvre CIB et Edahabia). Ces intégrations sont conçues de façon modulaire (services séparés) pour pouvoir évoluer (ex: remplacer Chargily par intégration directe quand on aura l’agrément bancaire).

***Étape 6 : Authentification JWT, Gestion des Rôles et Sessions Utilisateur***

La sécurité et la gestion des utilisateurs étant primordiales, nous mettons en place une authentification moderne basée sur JWT (JSON Web Tokens) combinée à des cookies de session pour le frontend web.

Authentification JWT : On utilise le module @nestjs/passport avec la stratégie JWT. Lors du login (/auth/login), le backend vérifie les identifiants (après avoir hashé le mot de passe fourni et comparé au hash stocké en DB). En cas de succès, on génère un JWT signé (avec une clé secrète stockée dans nos configs). Le payload du JWT inclura l’identifiant utilisateur et son rôle (et éventuellement des claims comme is Verified pour éviter de recharger user à chaque requête). Ce token est ensuite envoyé au client. Pour une application web, on ne veut pas l’exposer en JavaScript (pour éviter les XSS) : on le transmet donc dans un cookie HTTPonly. Par exemple, via response.cookie('access-token', jwt, {httpOnly: true, sameSite: 'strict', secure: true}) depuis NestJS. Ainsi, le navigateur du client stocke le token de manière non lisible par JS, et l’enverra automatiquement à chaque requête API subséquente (si le domaine correspond et same Site le permet). Pour l’application mobile (Flutter), on ne bénéficiera pas de cookies de navigateur, on pourra donc soit stocker le JWT côté app de manière sécurisée (ex: Secure Storage) et l’envoyer en Authorization Bearer header sur chaque requête, soit utiliser le même mécanisme de cookie via WebView ou autre. Dans tous les cas, le backend doit supporter l’extraction du JWT soit depuis le header Authorization, soit depuis le cookie (on peut adapter le guard JWT pour qu’il cherche dans les deux).

Le JWT contiendra un champ de rôle. Nous définirons sans doute trois rôles : CLIENT, AGENCY, ADMIN. Cela permettra de restreindre l’accès à certains endpoints. Par exemple, les routes commençant par /agency/ ne seront accessibles qu’aux JWT de rôle AGENCY. On utilisera pour cela un Guard custom ou le décorateur @Roles() de N Est combiné avec un Rôle Guard qui filtre en fonction de user.role dans le token.

Gestion des sessions & cookies : En utilisant les JWT stateless, on évite de stocker la session en base (scalabilité). Cependant, pour plus de sécurité, on peut coupler avec un mécanisme de Refresh Token. Par exemple, on émet un JWT d’accès de courte durée (15 min) et un Refresh Token de plus longue durée (7 jours) stocké aussi en HttpOnly cookie. Le refresh token pourrait être lié en DB (table users tokens) pour pouvoir le révoquer (par ex, logout ou vol de token). Ce niveau n’est pas strictement nécessaire au MVP, on pourrait se contenter d’un JWT valable plusieurs heures/jours et demander de se reconnecter après expiration. Mais pour une meilleure UX, le refresh token est recommandé. En tout cas, la présence du cookie JWT fait que le client reste logué et ses requêtes API incluront automatiquement l’authentification.

Gestion des rôles et autorisations : Outre les endpoints différenciés, on s’assure dans le backend d’appliquer des guards sur toutes les routes sensibles :

On utilise le guard AutoGuard('jwt') de Nest sur toutes les routes nécessitant d’être connecté. Cela vérifiera la validité du JWT sur chaque requête (vérification de signature et expiration).

On utilise un Rôle Guard (simple à implémenter) pour vérifier le rôle du bus selon l’exigence de la route. Par exemple, @Roles('AGENCY') sur le controller Agency Controller ou sur des méthodes, couplé au Roles Guard qui, dans Can Activate, checke que request.user.role correspond.

Pour l’admin, on peut avoir un module Admin avec un gars qui n’autorise que les admins.

Gestion des sessions multi-appareils : Si un utilisateur se connecte sur web et mobile, on aura deux JWT différents. Ce n’est pas un problème, mais il faut penser à la révocation (logout). Si l’utilisateur change son mot de passe ou est supprimé, on voudra invalider ses tokens existants. Sans stockage côté serveur, on ne peut pas invalider un JWT avant son expiration (sauf en gardant une blacklist en mémoire ou en DB des tokens invalidés jusqu’à expiration). Pour MVP, on peut ignorer ce cas (les tokens expirent d’eux-mêmes). Mais on notera l’option d’implémenter un jwtId et conserver une liste de tokens valides en base pour pouvoir les rendre invalides (ce qui rapproche d’une session traditionnelle). C’est un choix de design entre pure stateless et contrôle plus fin.

Dans tous les cas, la transmission via cookie HTTPonly ajoute une sécurité contre les attaques XSS (le JS malveillant ne peut voler le token facilement). On devra toutefois se protéger des attaques CSRF puisque le cookie est automatiquement envoyé. Pour ça, on peut soit :

N’autoriser le cookie qu’en Same Site=Lax/Strict (ce qui limite l’envoi cross-site, mais si on a front sur même domaine ça va).

Implémenter un mécanisme CSRF token synchronisé (un peu lourd pour JWT, pas indispensable si on respecte SameSite strict et qu’on n’autorise pas d’appel cross-origin).

Ou plus simplement, comme l’API sera sur un sous-domaine séparé peut-être (api.ekr… vs app.ekr…), on activera CORS avec credentials: true pour le domaine de l’appli, et on aura Same Site=None Secure pour le cookie. Dans ce cas, il faut un CSRF token car le cookie sera cross-site. On peut décider d’héberger l’API et le front sur le même domaine (juste des routes différentes) pour éviter le casse-tête CORPS/CSRF. Par exemple, tout sur ekrimendarek.com où les requêtes XHR vont sur ekrimendarek.com/api/... – ainsi, Same Site=Lax permet au cookie de passer et un formulaire malicieux externe ne pourrait pas facilement être exploité sans un lien direct.

Hachage des mots de passe : Naturellement, on stocke les mots de passe avec un sel et un hash (par ex. bcrypt avec 10+ rounds). NestS ne le fait pas out of the box, mais on utilisera la bibliothèque bcrypt ou argon 2 dans le service lors de la création et la vérification des passwords. On ne transmet jamais de mdp en clair à part au moment du login via HTTPS.

Confirmation d’email ou 2FA : Pour renforcer la confiance, on pourrait exiger confirmation de l’adresse email (envoyer un lien avec token). C’est une amélioration potentielle. De même, pour les agences, on pourrait exiger validation manuelle de l’équipe (pour contrôle qualité). Ce genre de processus peut être intégré plus tard, et l’architecture (via un module Auth et User bien séparé) le permet sans tout refondre.

En résumé, notre système d’auth s’appuie sur JWT \+ Cookies pour combiner le meilleur des deux mondes (stateless et sécurité navigateur). On obtient ainsi une expérience utilisateur fluide (connexion persistante) tout en segmentant bien les rôles (clients ou agences vs admins) pour que chacun n’accède qu’aux ressources autorisées.

***Étape 7 : Middlewares de Sécurité & Guards d’Accès***

En complément de l’authentification, on met en place divers middlewares et guards dans le backend pour renforcer la sécurité et moduler l’accès aux ressources :

Validation globale des données : On active le ValidationPipe de Ne tJS au niveau global, couplée à des DTOs pour chacune de nos routes. Ainsi, chaque payload reçu (que ce soit pour un login, une création de véhicule, etc.) sera automatiquement validé (types, formats, champs requis) avant même d’atteindre la logique métier. Cela évite bien des erreurs et protège contre des données mal formées. Par exemple, on définit un DTO CreateBookingDto avec vehicleId obligatoire, startDate futur, etc., et si le client envoie un JSON incorrect, on retourne 400 sans exécuter la suite. C’est une bonne pratique pour garder le backend robuste.

Helmet & sécurisation HTTP : On utilise le middleware helmet() pour ajouter des en-têtes de sécurité HTTP standard (anti XSS, anti sniffing, etc.). Aussi, on s’assure que notre serveur force l’utilisation de HTTPS en production (HSTS header).

CORS : Si le frontend web est servi sur un domaine différent du backend API, on configure correctement CORS (origines autorisées, credentials true si on utilise cookies cross-site). On limite aux domaines connus (par ex. le domaine de notre app web et peut-être localhost:3000 pour dev). On bloque tout le reste.

Rate Limiting : Pour prévenir les abus (DDoS ou brute-force), on peut activer le module Throttle de Ne tJS sur certaines routes sensibles. Par exemple, limiter /auth/login à X tentatives par minute par IP pour éviter brute force sur mdp. Ou limiter globalement l’API à, disons, 100 req/sec par IP ce qui est largement suffisant pour un usage normal et filtre les bots. Nest propose facilement un Throttle Guard configuré par route ou global.

Guards d’authentification et de rôle : Comme abordé en étape 6, on crée des guards et on les applique. Par exemple, un guard Jw mouthGuard (fourni par Passport JWT) protègera toutes les routes sauf celles publiques. On peut l’appliquer via le mécanisme global (ap.use Global Guards) ou via des décorateurs @UseGuards sur les controllers. De même, le Rôle Guard vérifiera req.user.role. On le combinera au décorateur custom @Roles('ADMIN') ou autre. Ces guides garantissent qu’un utilisateur non authentifié n’accède pas aux routes privées, et qu’un client ne peut pas appeler une route d’agence ou admin. C’est essentiel pour la sécurité multi-rôles.

Middleware de logging : Il peut être utile d’ajouter un middleware qui logge chaque requête (méthode, URL, durée, code réponse). Cela aide à monitorer l’application en production et à déceler des problèmes de performances ou des abus. NestJS permet de brancher un middleware ou utiliser son Logger. On pourrait par exemple utiliser Morgan pour les logs HTTP.

Gestion des erreurs globales : On peut implémenter un filtre global (ExceptionFilter) pour attraper les erreurs non gérées et retourner des réponses formatées uniformément (JSON avec message, etc.). Ceci pour ne pas laisser fuiter de stacktrace ou d’informations sensibles au client. Par exemple, toute exception de type Unauthorized Exception renvoie un 401 JSON propre, etc.

Compression : Activer le middleware de compression (gzip) pour réduire la taille des réponses (notamment les listings de véhicules, etc.). Cela améliore les performances perçues.

Guards spécifiques business : On peut créer des guards additionnels selon des règles métier :

Kyc Guard empêche un utilisateur de créer une réservation si son KYC n’est pas fait. Par exemple, sur la route POST /bookings, on peut vérifier user.is Verified et retourner un 403 avec un message "Veuillez d’abord vérifier votre identité (ajouter votre permis de conduire)" si false. Ainsi on force ce passage important.

Agency Active Guard : empêche qu’une agence non approuvée (ou désactivée par admin) accède aux routes agence. On pourrait avoir un champ agency.is Active; le guard vérifie que si user.role==AGENCY, alors user.agency.isActive \== true. Sinon 403 avec message "Votre compte agence est en cours de validation".

Ownership Guard : on peut aussi s’assurer qu’un utilisateur ne modifie que ses ressources. Par exemple, un client ne doit voir que ses propres bookings, une agence ne doit gérer que ses véhicules. On peut gérer ça soit par un check dans le service (ex: en filtrant les requêtes DB par l’id de l’utilisateur connecté), soit via un gars qui, après que le JetGuard a mis req.user, va vérifier par exemple si req.params.vehicleId appartient bien à req.user.agencyId. Ce guide serait appliqué sur les routes type PUT/DELETE vehicle, confirm booking, etc., pour double sécurité. Souvent on le fait dans le service, mais un guard rend la logique d’autorisation plus déclarative.

Rôles et permissions futures : Si plus tard on a des permissions fines (ex: un rôle EMPLOYÉ d’agence qui peut gérer les véhicules mais pas les paiements), on pourrait intégrer Casl ou un système ABAC. Pour l’instant, ce n’est pas nécessaire, le rôle suffit.

Protection des données sensibles : S’assurer que les endpoints n’exposent pas plus d’infos que nécessaire. Par exemple, quand une agence liste les réservations, on peut omettre le champ user.passwordHash évidemment, et peut-être même ne pas donner l’email du client directement dans l’API (ou le donner quand même car l’agence en aura besoin pour contact ? Peut-être juste le téléphone). On peut utiliser les Transformers (Interceptors) de Nest ou class-transformer pour exclure certains champs dans les réponses DTO. On a mentionné l’envoi du numéro de tél/email dans le voucher pour contacter, donc au moins pour une réservation confirmée, l’agence doit voir les coordonnées du client. On donnera ces infos ciblées, mais on protège tout ce qui est inutile (ex: les tokens, etc.).

En combinant ces middlewares et guards, on obtient une API sûre, bien gardée et structurée. Chaque requête sera validée, authentifiée, autorisée avant d’exécuter la logique, ce qui renforce la fiabilité. Côté infrastructure, on peut aussi utiliser un WAF (Web Application Firewall) ou Cloudflare pour filtrer le trafic malveillant en amont, mais cela dépasse le cadre de l’architecture logicielle.

***Étape 8 : Frontend – Accessibilité, SEO et Performance***

Bien que le backend soit crucial, il ne faut pas négliger le frontend – vitrine directe auprès des utilisateurs. On optimise donc le front pour l’accessibilité, le référencement SEO et la performance perçue, en accord avec les standards modernes.

Accessibilité (a11y) : On veille à respecter les bonnes pratiques WCAG. Par exemple, utiliser les éléments HTML sémantiques appropriés (titres h1/h2, listes, boutons \<button\> plutôt que \<div\> cliquable, etc.), ajouter des labels et des attributs ARIA aux composants interactifs pour les technologies d’assistance. Les contrastes de couleurs doivent être suffisamment élevés pour les textes. On s’assure que le site est navigable au clavier (focus visible, ordre logique). Ceci est important pour toucher un public large et améliorer l’expérience globale, sans compter que Google valorise les sites accessibles. Dans notre contexte, ça signifie par exemple : pour le formulaire de réservation, bien associer chaque champ de saisie à un \<label\>, fournir du texte alternatif pour les images de véhicules (ex: alt="Photo de Renault Clio 2018 blanche"), etc.

SEO (Optimisation pour les moteurs de recherche) : Étant une plateforme type “Booking”, une bonne partie du trafic viendra du web via Google. On doit donc rendre le site indexable. Si on utilise Next.js ou Angular Universal, on active le rendu côté serveur (SSR) pour les pages critiques (page d’accueil, pages liste de véhicules par région, pages de détails de véhicule). Par exemple, une URL comme krimen.../location-voiture/Alger/Clio-4-2018 pourrait correspondre à la page d’un véhicule ou d’une recherche filtrée. Avec SSR, le HTML servira directement le contenu aux crawlers, incluant le texte descriptif du véhicule, les avis, etc., ce qui améliorera notre classement SEO. On ajoutera des métadonnées optimisées sur chaque page (title, meta description unique par véhicule/agence, balisage JSON-LD possiblement pour les avis/étoiles). Le cahier des charges mentionne d’ailleurs le SEO/SEA comme levier B2C, signifiant qu’on doit pouvoir se positionner sur des mots-clés comme "Location voiture Alger". Il faut donc que nos pages correspondantes soient bien construites. Si on choisit Flutter Web pour le site, le SEO serait plus compliqué (Flutter génère du canvas, pas idéal pour Google). Il serait sans doute judicieux de développer le site web front avec un framework web (Next/Angular) séparément de l’app mobile Flutter, afin d’optimiser SEO et accessibilité. C’est un choix d’architecture front : web et mobile ayant des besoins différents, on peut partager l’API mais pas forcément le code UI.

Performance Web (Web Vitals) : On implémente des techniques pour que le site soit rapide et réactif. Quelques points clés :

Chargement différé (lazy loading) : On ne doit charger que ce qui est nécessaire au départ. Par exemple, sur la page d’accueil ou la page de recherche, on charge d’abord les éléments essentiels et on retarde le chargement des images en bas de page ou des composants non immédiatement visibles. On utilise le lazy loading d’images (attribut loading="lazy" ou des librairies Intersection Observer) pour que les photos de véhicules ne se chargent qu’au scroll. Idem pour les modules de pages secondaires : par ex, ne charger le code du module "Profil utilisateur" que si l’utilisateur navigue dessus.

Skeleton screens : Pour améliorer la perception lors des appels réseau (par ex chargement de la liste de véhicules ou de la fiche véhicule), on affiche des squelettes – des placeholders grisés où le contenu apparaît. Ainsi, au lieu de voir un écran vide ou un spinner, l’utilisateur voit une structure simulant la page, ce qui donne l’impression que le site est plus rapide et évite un flash brutal. On le fera pour les cartes de véhicule en résultat de recherche, pour la fiche (montrer un cadre d’image en attendant la photo, etc.).

Mise en cache et CDN : Les ressources statiques (images, CSS, JS bundles) seront servies avec de la mise en cache (headers Cache-Control) via un CDN si possible. Les photos de voiture, en particulier, on peut les héberger sur un bucket cloud (S3 ou autre) derrière CloudFront/Cloudflare, pour accélérer l’accès global. On peut générer des miniatures (thumbnails) pour les listes afin de ne pas charger l’image pleine résolution inutilement. Le backend ou un service d’upload peut créer des versions réduites.

Optimisation des bundles : Si on utilise Webpack/Angular CLI, on activera la minification, tree-shaking, etc. On surveillera le Time To Interactive. Par exemple, éviter d’embarquer de grosses librairies inutiles. Peut-être utiliser un mapping lazy des communes/wilayas (si on a une liste pour la recherche) plutôt que charger tout d’un coup.

Compression d’images : On encourage que les images de véhicules uploadées soient compressées (on peut utiliser par ex Sharp ou un service pour redimensionner et compresser à l’upload). On peut définir une résolution max (par ex 1600px large) pour éviter les photos 10 MB brutes. Ça rejoint l’étape upload photos.

Pré-chargement : Pour l’app web, on peut précharger certaines données ou pages anticipativement. Par exemple, une fois qu’un utilisateur commence une réservation, on sait qu’il ira probablement sur la page de paiement, on peut précharger le chunk JS correspondant en tâche de fond.

Mesures : On intégrera Google Analytics ou un outil pour suivre les Core Web Vitals (LCP, FID, CLS) en prod, et ainsi détecter les éventuels soucis de performance réelle.

Responsive Design & PWA : Bien que l’app mobile soit prévue via Flutter, il est intéressant que le site web soit responsive et utilisable depuis mobile browser. Car un certain nombre de voyageurs pourraient ne pas installer l’app native et utiliser juste le site. Donc on utilise un design adaptatif (CSS flex/grid, breakpoints) pour que la liste de véhicules s’affiche correctement sur un écran de smartphone. On peut aussi faire du site web une Progressive Web App (PWA) : on ajoute un manifest.json, un service worker pour la mise en cache offline de base, permettant à un utilisateur de "télécharger" le site sur son écran d’accueil. Ce n’est pas indispensable avec l’app Flutter dispo, mais c’est un bonus pour les utilisateurs occasionnels.

Multilinguisme : L’accessibilité inclut aussi la langue. Selon la cible, on aura potentiellement besoin de français/anglais/arabe. Le backend devrait supporter l’i18n (messages d’erreur en français par ex). Le frontend, on peut l'architecture pour supporter plusieurs langues (fichiers de traduction). Puisque beaucoup de clients seront des émigrés d’Algérie en France/Canada l’été, le français et un peu d’anglais suffiront probablement, l’arabe pourrait être une amélioration future.

En appliquant ces optimisations, on s’assure que la plateforme offre une expérience fluide : pages rapides à charger, interactions sans latence, et visible dans les moteurs de recherche. Un site plus rapide et SEO-friendly attirera plus d’utilisateurs organiques, réduira le taux de rebond, et augmentera les conversions (réservations).

En parallèle, ces efforts front contribuent aussi à la mobilité mobile performance (parce que sur des réseaux 3G algériens parfois lents, il faut être efficace). Enfin, n’oublions pas la compatibilité navigateur : on testera sur Chrome, Firefox, Safari, mobile Android/iOS. Utiliser des polyfills si on vise des vieux navigateurs (ex: IE11 peu probable qu’on le supporte en 2025, mais Edge/Firefox oui).

***Étape 9 : Fonctionnalités Backend liées à la Rentabilité (Commission, Webhooks, Upload Photos)***

Pour garantir la rentabilité du modèle économique et la qualité du service, on intègre dans l’architecture plusieurs éléments côté backend :

Gestion des Commissions : Comme vu, notre revenu provient de la commission (acompte) sur chaque transaction. Techniquement, dès qu’un paiement est réussi, nous avons cet argent sur votre compte marchand. La plateforme doit en garder la trace. Grâce au modèle Payment/Booking décrit, on peut facilement calculer la commission totale sur une période (somme des Payment.amount). On peut envisager un module Finance/Accounting qui consolide ces chiffres et, éventuellement, gère la facturation. Par exemple, pour chaque paiement, on peut émettre un reçu électronique pour l’utilisateur (via email) mentionnant qu’il a payé X DA d’acompte pour le service. De plus, on pourrait vouloir reverser une partie à l’agence ? Ici non, puisque l’agence touche le reste en direct, l’acompte est 100% pour nous. Cependant, imaginons plus tard qu’on encaisse 100% (si le marché évolue), on aurait à verser 88% à l’agence après coup. Ce système de reversement n’est pas d’actualité initialement (et l’expert a déconseillé d’encaisser 100% tant que la caution n’est pas gérable en ligne). Néanmoins, on peut prévoir la structure pour : par ex, un champ commission Rate dans la table Agency si jamais on fait varier la commission selon l’agence ou promos. Et un système de payout si nécessaire. Pour l’instant, le plus important est de calculer et afficher éventuellement dans l’admin le montant de commissions généré (par booking, par mois...). On peut aussi notifier l’admin si une réservation à haut montant est passée, etc. Tout ceci pour piloter le business.

Webhooks post-paiement & flux de travail : Le webhook de paiement (vu étape 4/5) est un point central. On doit s’assurer qu’après réception d’un paiement réussi, le flux de travail continue correctement :

Envoi des notifications (WhatsApp/email) au client.

Notification à l’agence : idéalement, l’agence devrait recevoir une notification en temps réel qu’une demande de résa vient d’arriver. On peut envisager l’envoi d’un email à l’agence ou même un message WhatsApp (si on a l’API, pourquoi pas notifier l’agence via WhatsApp également). Ou plus moderne, une notification push si l’agence utilise une app. Dans un premier temps, un email "Vous avez une nouvelle réservation, veuillez le confirmer sous 2h" suffira.

Démarrage du timer de 2h : on peut via un background job enregistrer un délai, et si 2h s’écoulent sans action de l’agence, on auto-confirme. Pour cela, on peut utiliser un système de queue (par ex BullES avec Redis) ou plus simplement un champ expires SAt sur Booking et un cron job qui tourne toutes les X minutes pour auto-confirmer celles expirées. Un module de tâches planifiées dans Nest (basé sur @Schedule ou un service cron) peut gérer ça. L’auto-confirmation consiste à changer le statut \-\> CONFIRMED et renvoyer le vœu si pas déjà fait. Cette automatisation assure que le client ne reste pas sans réponse. Si on voulait être plus sophistiqué, on pourrait auto-annuler à la place, mais l’expert suggérait une auto-validation si le calendrier de l’agence est synchronisé. Disons qu’on prend le parti de confirmer automatiquement si pas de refus.

Webhooks pour d'autres événements : éventuellement, si on intègre des services externes (ex: un CRM ou un outil analytics), on pourrait émettre des webhooks ou des événements internes. Une architecture event-driven pourrait être envisagée (ex: un event "BookingConfirmed" qui déclenche listeners pour notification, etc.), mais ça complexifie. On peut se contenter d’appeler directement les services depuis notre code after payment.

Système d’Upload de Photos (professionnelles) : La qualité des photos est un élément différenciateur face aux concurrents informels. On doit donc faciliter l’upload de photos de haute qualité pour les véhicules. Architecture :

Côté frontend agence, on fournit une interface pour uploader plusieurs images (idéalement via glisser-déposer).

Le backend reçoit ces fichiers sur un endpoint (ex: POST /api/v1/vehicles/{id}/photos). On utilise un middleware de gestion de fichiers (NestJS peut utiliser Multer pour parser le multi-part). On stocke les fichiers soit sur le système de fichiers du serveur (peu recommandé en microservices/scaling), soit sur un stockage cloud (S3, Google Cloud Storage...). Choix : utiliser un bucket S3 compatible (il y a des providers locaux ? Sinon AWS directement). On peut depuis le backend envoyer le fichier sur S3 puis renvoyer l’URL. Ou générer un lien de téléchargement direct (signed URL) pour que le frontend envoie directement au bucket sans transiter par notre backend (économie de bande passante). Pour MVP, transit via backend est plus simple.

Une fois stockée, on sauvegarde l’URL dans la base (table VehiclePhotos ou champ images).

Traitement : On peut ici intégrer un traitement d’image à la volée : redimensionner en plusieurs résolutions (thumbnail, medium, original) pour optimiser l’affichage. Des librairies comme Sharp en Node sont utiles. On peut aussi rajouter un watermark discret (logo du site) sur les photos si on craint le vol de contenu, mais ce n’est peut-être pas nécessaire.

Validation : On veut des photos professionnelles. Si on envoie nous-mêmes des photographes, ils pourraient uploader leurs photos peut-être via une interface admin, ou envoyer aux agences. Une fonctionnalité possible : l’image uploadée par l’agence doit être approuvée par un admin avant publication (pour vérifier qu’elle est de bonne qualité et conforme). On peut ajouter un champ isApproved sur la photo. L’admin aura une interface pour voir les nouvelles photos et les valider. En attendant, le site peut montrer un badge "Photo vérifiée" sur celles approuvées. Ce n’est pas explicitement demandé, mais “photos pro obligatoires” implique qu’on doive inciter fortement à la qualité, via peut-être une charte envoyée aux photographes/agences.

On garantit également que les images ne soient pas trop lourdes (on peut imposer une limite dans l’endpoint, ex: refuser \>5MB, et compress/resize comme dit).

L’architecture peut prévoir un service d’asset management séparé si on voulait, mais c’est surdimensionné pour MVP. Une simple solution de fichiers suffira.

Éléments liés à la rentabilité : En plus de la commission, le cahier des charges mentionne d’autres sources de revenus potentielles (Upsell d’assurance, placements sponsorisés). Ces éléments peuvent influencer l’architecture :

Assurance complémentaire : Cela signifie qu’on pourrait avoir une offre d’assurance vendue lors de la réservation. Par ex, "rachat de franchise pour X DA". Si on implémente cela, dans le flow de réservation, on ajouterait une étape pour choisir l’assurance, et si oui, ajouter une ligne de paiement en plus (et potentiellement une autre commission ou un partage avec l’assureur). On peut modéliser une table insurance\_options et un champ booking.insuranceChosen etc. Ou plus simple, on traite l’assurance comme un produit additionnel avec un prix fixe, et on ajoute ce montant à l’acompte (ou on le fait payer séparément). Pour l’instant, on peut laisser de côté, mais l’architecture devrait être suffisamment flexible pour l’ajouter plus tard (par ex, ne pas tout coder en dur sur "15% commission", mais permettre d’ajouter d’autres items).

Annonces sponsorisées (agences payant pour être en tête) : Si on souhaite plus tard monétiser ainsi, il faudra adapter le système de recherche pour intégrer un paramètre de classement sponsorisé. Par exemple, une table agency\_promotions ou un champ sur l’agence sponsorLevel qui influe sur l’ordre des résultats (d’abord les sponsors). À l’architecture actuelle, ce n’est pas prioritaire, mais mentionnons que le tri des résultats n’est pas purement par prix, il peut être hybride (par défaut on pourrait trier par pertinence/qualité, et injection de sponsor). Ce genre de logique sera implémentée côté backend (dans l’endpoint GET /vehicles on peut appliquer un scoring).

Comptabilité et fiscalité : Comme plateforme encaisse des paiements, il faudra gérer la facturation. On devrait numéroter les transactions, possiblement générer des factures pour les commissions prises (surtout si la société est en Algérie, pour la compta et les éventuelles taxes). Prévoir d’extraire ces données facilement (un admin dashboard montrant les paiements du jour, etc.). L’architecture logicielle peut inclure un AdminModule pour ces aspects (tableau de bord financier, validation KYC, modération avis, etc.).

Gestion des litiges : Si un client se plaint ou annule, ou si une caution n’est pas rendue et qu’il contacte la plateforme, il faut un moyen pour les admins de voir les données et potentiellement intervenir. Encore une fois, un AdminModule où on peut rechercher une réservation, la modifier, la marquer en litige, etc., pourrait être nécessaire en backend même si non exposé publiquement.

En intégrant tous ces éléments, notre backend n’est pas seulement une suite de CRUD, mais une orchestration de workflows orientés vers la monétisation et la qualité de service. La commission en ligne couplée aux webhooks assure que chaque réservation génère du revenu instantané (2 250 DA pour 15 000 DA de location dans l’exemple, soit 15%) et engage le client à honorer sa réservation. Le système d’upload photo garantit que la plateforme montre des visuels attractifs (avantage concurrentiel sur Ouedkniss selon l’étude). L’ensemble de ces fonctionnalités doit être conçu de manière fiable pour gagner la confiance des utilisateurs et des agences, condition sine qua non de la réussite sur ce marché fragmenté.

***Étape 10 : Documentation de l’API & Versionnement***

Une architecture professionnelle doit s’accompagner d’une bonne documentation technique, surtout pour une API qui sera consommée par le frontend et peut-être plus tard par des partenaires. Nous mettons en place la documentation Swagger dès le départ, et nous gérons proprement la version de l’API :

Swagger (OpenAPI) : Grâce à la library @nestjs/swagger, on peut auto-générer une documentation interactive. On va décorer nos DTOs et nos contrôleurs avec les décorateurs Swagger (ex: @ApiTags, @ApiOperation, @ApiResponse, etc.) afin de décrire chaque endpoint (paramètres attendus, schéma de réponse, codes d’erreur possibles). Cela produira une page web (généralement accessible sur /api/docs ou /docs) où on peut voir toutes les routes, essayer des requêtes, visualiser les modèles. Cette doc sera versionnée également pour l’API v1. On peut par exemple la servir à /api/v1/docs. Si à l’avenir on sort une v2 non rétro-compatible, on pourrait héberger deux documentations simultanées (v1 et v2) pour faciliter la transition.

Versionnement de l’API : On adopte une stratégie de versioning URI simple pour commencer (c’est déjà reflété dans nos routes /api/v1/...). NestJS facilite le versioning soit globalement soit par contrôleur. On peut configurer app.setGlobalPrefix('api/v1') ou utiliser le VersioningType.URI. Ainsi, toutes les routes actuelles sont v1. Si on apporte des changements majeurs (par ex, changer la structure des données renvoyées ou les règles business) qui cassent la compatibilité, on créera de nouvelles routes sous /api/v2. L’ancien front pourra continuer d’appeler v1 si besoin, mais comme on contrôlera front et back en même temps (projet interne), on pourra migrer tout le monde sur v2 et déprécier v1. Néanmoins, c’est une bonne pratique de prévoir ce mécanisme. On peut aussi versionner via le header Accept or media type, mais c’est overkill pour notre cas, l’URL version est simple et claire.

README & Guides : Outre la doc Swagger, on rédigera un fichier README.md dans le repo backend pour expliquer comment installer le projet, lancer en dev, infos sur la configuration (env vars nécessaires comme DATABASE\_URL, JWT\_SECRET, API\_KEYS for payment, etc.). On peut aussi documenter l’architecture (un petit schéma des modules et relations par exemple). Ce document aide les nouveaux développeurs à onboarder le projet plus vite.

Documentation développeur externe : Si on prévoyait d’ouvrir l’API à des tiers (par ex, si un jour on veut que d’autres apps puissent réserver via notre API), on soignera la doc Swagger en anglais possiblement et on pourrait héberger un portail dev. Pour l’instant ce n’est pas la cible, la doc sert surtout en interne et pour le front.

Commentaire de code : On encouragera l’équipe à commenter les parties complexes, utiliser un style propre, etc. On peut aussi utiliser un outil comme Compodoc (pour Nest) ou Storybook (pour le front) pour documenter les composants UI.

Contrat API et Front : Comme front et back sont développés en parallèle, on peut utiliser Swagger Codegen ou NestJS CLI plugin pour générer des clients API en TS pour le front-end, ce qui évite de dupliquer les types d’interface. Par exemple, utiliser la définition OpenAPI pour générer un client axios typé. Ainsi, l’équipe front peut importer ce client et avoir des méthodes prêtes pour appeler /vehicles etc., avec les types de réponse attendus, réduisant les erreurs. C’est un plus en termes de productivité.

En somme, toute l’API sera documentée et accessible facilement. Cela accélère le développement (moins de frictions entre front et back, qui peuvent tester via Swagger UI), et cela pose les bases pour la montée en version maîtrisée. Un API documentée inspire confiance également si jamais on la présente à des partenaires ou investisseurs techniques lors d’une due diligence.

**Étape 11 : Conseils DevOps – CI/CD, Docker, Environnements de Staging & Production**

Enfin, pour compléter l’architecture et faciliter la collaboration sur GitHub, on propose des bonnes pratiques de déploiement continu (CI/CD) et de gestion des environnements :

Contrôle de version (GitHub) : On utilisera GitHub pour le code source. Étant plusieurs développeurs, on adoptera un workflow (Git Flow ou au moins feature-branches \+ pull requests). Chaque PR sera revue (code review) et testée via la CI avant merge, afin de maintenir la qualité.

Intégration Continue (CI) : On peut configurer GitHub Actions pour automatiser certaines tâches à chaque commit/pull request :

Lancer les tests unitaires et d’intégration (quand ils seront écrits) du backend et du frontend.

Vérifier le linting (ESLint, Prettier) pour assurer un style de code uniforme.

Construire les projets (par ex, compiler l’app front en prod build, builder l’image Docker).

Éventuellement, exécuter l’analyse statique de sécurité (il existe des actions pour détecter les vulnérabilités connues dans les dépendances).

Si tout est vert, déployer automatiquement sur un environnement de staging (ou au moins créer une image Docker livrable).

Dockerisation : On fournira un Dockerfile pour le backend NestJS (Node 18 slim, copy code, install, build, run npm run start:prod). Idem pour le frontend (si Next.js, un Dockerfile multi-stage qui build puis sert via Node or a static server; si Angular, build puis Nginx serve static). Pour Flutter mobile, le déploiement est différent (store), Docker n’est pas nécessaire pour mobile app, mais on peut dockeriser une version web de Flutter si on en avait une.

On peut aussi utiliser Docker Compose pour orchestrer localement les services (ex: backend \+ DB Postgres \+ maybe Redis si on use it for cache/queue). Fournir un docker-compose.yml dans le repo pour faciliter le lancement d’un environnement complet local pour un dev.

En prod, les conteneurs permettent une scalabilité aisée (on peut les déployer sur un cluster).

Staging : On va mettre en place un environnement de staging (pré-production) qui est un miroir de la prod où l’équipe peut tester les nouvelles fonctionnalités avec de vraies conditions avant mise en prod. Ce staging aura sa propre base de données, éventuellement plus petite. On y déploiera automatiquement (via CI) la branche develop ou les versions validées. On peut protéger l’accès (basiquement par un login global ou limiter aux IP de l’équipe) pour éviter que de vrais utilisateurs y accèdent.

Les clés API de test pour paiement seront différentes en staging (mode sandbox de CIB/Chargily).

Cela permettra par exemple de simuler un paiement sans réellement débiter, pour tests.

On utilisera des comptes de test (ex: un user client test, une agence test).

Production : Une fois les features testées et approuvées en staging, on déploie en production. Là, on doit s’assurer de la haute disponibilité et de la robustesse :

Hébergement possiblement sur un cloud. Par ex, déployer les conteneurs sur AWS (ECS ou Elastic Beanstalk) ou Azure, ou un PaaS style Heroku/Render. Ou localement sur un VPS bien dimensionné (selon budget).

Utiliser une base de données managée (ex: Amazon RDS) pour fiabilité, ou une instance Postgres sur serveur avec backups automatiques.

Configurer la scalabilité horizontale si on anticipe de fortes charges (peak en été). Par ex, on peut avoir 2 instances backend derrière un load balancer. Dans ce cas, attention aux sessions : on a choisi JWT stateless donc pas de souci de sticky session. Mais pour websockets ou realtime notifications ça pourrait, on n’en a pas encore, donc OK.

Logging & Monitoring : En prod, brancher un système de logs centralisé (ELK stack ou un service SaaS) pour collecter les logs de tous containers, faciliter le debug. Mettre en place des métriques (ex: avec Prometheus/Grafana ou un service comme Datadog) pour surveiller CPU, RAM, temps de réponse, taux d’erreur. Au moins utiliser un uptime monitoring (Pingdom, UptimeRobot) pour être alerté si l’API tombe.

Environnement : Utiliser les variables d’environnement pour toute config sensible (clés API, secrets JWT, URL DB). Ne jamais committer ces secrets. Sur GitHub Actions, utiliser GitHub Secrets pour injecter lors du build/deploy. Sur le serveur, utiliser un fichier .env ou le service de secret du cloud.

Backups : Planifier des sauvegardes régulières de la base de données (journalières minimum), et tester la restauration. Idem pour un bucket de fichiers (sauvegarde ou config de versioning).

CDN & Domaines : Configurer le nom de domaine du site (ex: ekrimen…dz) et attacher un CDN/Cache pour accélérer la distribution du frontend statique. Utiliser un certificat SSL (via Let’s Encrypt ou autre) partout.

Pipeline CI/CD : On peut automatiser la mise en production quand on crée une release (tag). Par exemple, sur push d’un tag v1.0, GitHub Actions construit les images Docker, les pousse sur un registry (Docker Hub ou GHCR), puis déclenche un déploiement (par ex en appelant AWS ECS update service, ou en SSH sur le serveur pour pull la nouvelle image). Cela réduit les déploiements manuels et les erreurs. Bien sûr, mettre en place du staging d’abord évite de déployer du code bugué en prod.

Collaboration : Sur GitHub, mettre en place des code owners pour valider certaines parties, des issues bien décrites, un Kanban (peut utiliser GitHub Projects) pour suivre l’avancement. Côté tests, inciter à écrire des tests unitaires (NestJS supporte Jest par défaut). Par exemple, tester les services critiques (calcul de prix, expiration 2h, etc.) pour prévenir les régressions.

Evolution & Maintenance : Documenter comment ajouter un nouveau module, comment effectuer une migration DB (Prisma migrate). Mettre en place éventuellement un versionnement de schéma via Prisma Migrate or guidelines pour ne pas casser la prod.

Grâce à ces pratiques DevOps, l’équipe de développement pourra travailler de manière fluide et sûre. Chaque nouvelle fonctionnalité passe par un cycle de qualité (CI, staging, revue) avant d’impacter les utilisateurs finaux. Le déploiement continu permet d’itérer rapidement, ce qui est précieux pour coller aux retours du marché. De plus, en containerisant l’application, on facilite la portabilité (on peut lancer la stack sur un nouveau serveur ou dev machine en peu de temps), et on isole les dépendances (par ex, garantir que la même version de Node est utilisée partout, etc.).

\---

**Conclusion**

Au terme de ces itérations, nous obtenons une architecture fullstack complète optimisée pour EkriMenDarek. Cette architecture est modulaire et scalable côté backend (NestJS \+ Prisma) – chaque entité clé est isolée, les relations bien définies, l’API REST est claire et documentée. Le frontend est intégré sans couture, prêt à offrir une expérience utilisateur de premier ordre grâce aux optimisations SEO, performance et accessibilité. Nous avons tenu compte des spécificités algériennes : paiement en ligne local (acompte obligatoire), gestion de la caution en dehors de l’application mais affichage transparent, notifications via WhatsApp plutôt que SMS, contraintes KYC adaptées (permis \>= 2 ans), et support du cash (85% sur place) sans compromettre notre commission.

L’ensemble est conçu pour être robuste (sécurisé par JWT, guards, validations), rentable (chaque réservation génère immédiatement des revenus, avec possibilité d’extensions upsell), et prêt pour la collaboration (code proprement structuré, CI/CD en place, documentation Swagger à jour). De plus, cette architecture est pensée pour l’évolution : ajout futur de fonctionnalités comme l’assurance, l’intégration d’un calendrier synchronisé, une éventuelle API publique, etc., sans refonte majeure.

En appliquant ce plan, EkriMenDarek disposera d’une base technique solide pour devenir le “Booking.com” de la location auto en Algérie, capable de gagner la confiance des utilisateurs et de s’adapter aux défis locaux du terrain. Il ne restera plus qu’à passer à la phase de développement concret en équipe, en tirant profit de cette architecture pour livrer rapidement un MVP de qualité puis itérer vers la production nationale en toute confiance.

Références (extraits du cahier des charges et sources) utilisées pour guider l’optimisation :

Spécificités du parcours utilisateur et paiement hybride, importance de la caution affichée et de l’acompte en ligne.

Fonctionnalités côté agence (gestion flotte, calendrier, liste rouge).

Exigences de recherche et fiches véhicules (filtres transmission/carburant/caution, conditions d’agence).

KYC léger avec upload permis \+ selfie et OCR automatique.

Envoi des confirmations par WhatsApp (canal privilégié).

Modèle de commission 10-15% en ligne (revenu plateforme) et exemple chiffré.

Nécessité d’avoir des photos professionnelles des véhicules pour se différencier.

Toutes ces informations ont été intégrées dans la conception pour garantir une solution au plus près des besoins exprimés. Ainsi architecturé, EkriMenDarek est prêt à passer du concept à la réalité \!